import * as types_mod from './types';
import * as util_mod from './util'
  class node<T> {
    right?: node<T>;
    left?: node<T>;
    index: number;
    constructor(public data: T) {
      this.index = -1;
    }
  }
  /**left:root directory to right right is tail */
  class Enumerator<T> {
    head?: node<T>;
    tail?: node<T>;
    _count: number;
    constructor() {
      this._count = 0;
    }
    *ergodic(isReverse?: boolean): Iterable<node<T>> {
      let temp: node<T>;
      if (isReverse) {
        temp = this.tail!;
        while (temp) {
          yield temp;
          temp = temp.left!;
        }
      } else {
        temp = this.head!;
        while (temp) {
          yield temp;
          temp = temp.right!;
        }
      }
    }
    insert(data: T): void {
      let temp = new node(data);
      if (!this.head) {
        this.head = this.tail = temp;
      } else {
        this.tail!.right = temp;
        temp.left = this.tail;
        this.tail = temp;
      }
      temp.index = this._count;
      this._count++;
    }
    findByIndex(index: number): node<T> | null {
      let target: node<T> | null = null;
      for (let i of this.ergodic()) {
        if (i.index == index) {
          target = i;
          break;
        }
      }
      return target;
    }
    removeAt(i: number): void {
      let target = this.findByIndex(i);
      if (!target) return;
      if (target.left) {
        target.left.right = target.right;
      } else if (target.right) {
        this.head = target.right;
      }
      if (target.right) {
        target.right.left = target.left;
        let temp = target.right;
        while (temp) {
          temp.index--;
          temp = temp.right!;
        }
      } else if (target.left) {
        this.tail = target.left;
      }
      this._count--;
      target = null;
    }
    updateAtIndex(index: number, newData: T): void {
      let target = this.findByIndex(index);
      if (!target) return;
      target.data = newData;
    }
    //清空
    dispose() {
      let temp: node<T> = new node<T>(null!);
      while (this.tail != null) {
        temp = this.tail.left!;
        this.tail.left = undefined;
        this.tail.right = undefined;
        this.tail = temp;
      }
      this.head = undefined;
    }
  }
  // interface IQueryView<Iqv> {
  //   Select<Out>(translate: (node: Iqv) => Out): SelectView<Iqv, Out>;
  //   get Result(): Array<Iqv>;
  //   OrderBy(sortor: (item: Iqv) => number, se?: SortEnum): QueryView<Iqv>;
  //   container(): boolean;
  //   valueContainer(): boolean;
  //   single(predicate: WhereHandler<Iqv>): Iqv;
  // }
  // interface ISelectView<Isv> {
  //   get Result(): Array<Isv>;
  //   OrderBy(sortor: (item: Isv) => number, se?: SortEnum): QueryView<Isv>;
  // }
  class QueryView<Qv> {
    constructor(private store: Store<Qv>, private source: Enumerator<Qv>) {
    }
    container(): boolean {
      throw new Error('Method not implemented.');
    }
    valueContainer(): boolean {
      throw new Error('Method not implemented.');
    }
    single(predicate: types_mod.WhereHandler<Qv>): Qv {
      return this.store.single<Qv>(predicate, this.Result);
    }
    #cache?: Array<Qv>;
    get Result(): Array<Qv> {
      // if (!this.predicate && this.#cache) {
      //   console.log('insert cache and get it');
      //   return this.#cache;
      // }
      this.#cache = Array.from<Qv>(this._Iterator());
      if (this.sortor) {
        util_mod.InsertOrder<Qv>(this.#cache, this.sortor!, this.ad);
      }
      this.predicate = undefined;
      this.sortor = undefined;
      return this.#cache;
    }
    private *_Iterator(): Iterable<Qv> {
      if (this.predicate) {
        for (let i of this.source.ergodic()) {
          if (this.predicate(i.data)) {
            yield i.data;
          }
        }
      } else {
        for (let i of this.source.ergodic()) {
          yield i.data;
        }
      }
    }
    predicate?: types_mod.WhereHandler<Qv>;
    ad?: boolean;
    sortor?: (item: Qv) => number;
    Select<Out>(transform: (node: Qv) => Out): SelectView<Qv, Out> {
      let temp = new SelectView<Qv, Out>(this.store, this);
      temp.transform = transform;
      temp.source = this.Result;
      return temp;
    }
    GroupBy<Key>(transform: (node: Qv) => Key): GroupView<Qv, Key> {
      let temp = new GroupView<Qv, Key>(this);
      temp.transform = transform;
      temp.source = this.Result;
      return temp;
    }
    OrderBy(sortor: (item: Qv) => number, se?: types_mod.SortEnum): QueryView<Qv> {
      this.sortor = sortor;
      this.ad = se == 'ascending' ? true : false;
      return this;
    }
  }
  class SelectView<Qv, Sv> {
    source?: Array<Qv>;
    transform?: (node: Qv) => Sv;
    constructor(private store: Store<Qv>, private owner: QueryView<Qv>) {

    }
    get Result(): Array<Sv> | undefined {
      return this.source?.map(this.transform!);
    }
    contains(i: Sv): boolean {
      // return this.store.container<Sv>(i, this.source?.map(this.transform!));
      // return false;
      return this.source?.map(this.transform!).includes(i) ?? false;
    }
  }
  class GroupView<Gv, Key> {
    source?: Array<Gv>;
    constructor(private owner: QueryView<Gv>) {
    }
    transform?: (item: Gv) => Key;
    get Result(): Array<{ key: Key, value: Array<Gv> }> {
      let temp = new Array<{ key: Key, value: Array<Gv> }>();
      if (!this.source) return temp;
      if (!this.transform) return temp;
      for (let i of this.source) {
        let key = this.transform(i);
        let index = temp.findIndex(x => x.key == key);
        if (index == -1) {
          temp.push({ key, value: [i] });
        } else {
          temp[index].value.push(i);
        }
      }
      return temp;
    }
  }
  export class Store<T> {
    private source: Enumerator<T>;
    private queryView: QueryView<T>;
    constructor() {
      this.source = new Enumerator<T>();
      this.queryView = new QueryView(this, this.source);
    }
    get count(): number {
      return this.source._count;
    }
    import(it: T | T[]) {
      if (Array.isArray(it)) {
        let iu = it as Array<T>;
        for (let i of iu) {
          this.source.insert(i);
        }
      } else {
        this.source.insert(it);
      }
    }
    dispose() {
      this.source.dispose();
    }
    query(predicate?: types_mod.WhereHandler<T>): QueryView<T> {
      if (predicate) {
        this.queryView.predicate = predicate;
      }
      return this.queryView;
    }
    //common
    container<C>(i: C, source: C[]): boolean {
      var result = false;
      result = source.some(k => k == i);
      return result;
    }
    valueContainer<C>(pridecate: types_mod.WhereHandler<C>, source: C[]): boolean {
      var result = false;
      return result;
    }
    single<C>(pridecate: (i: C) => boolean, s: C[]): C {
      let r: C = new Object() as C;
      for (let i of s) {
        if (pridecate(i)) {
          r = i;
          break;
        }
      }
      return r;
    }
  }

  export namespace Set {
    /**binary tree avl*/
    export class AvlNode<T> {
      left?: AvlNode<T>;
      right?: AvlNode<T>;
      height: number;
      constructor(public data: T) {
        this.height = 1;
      }
      insert(node: AvlNode<T>): void {
        if (node.data < this.data) {
          if (this.left) {
            this.left.insert(node);
          } else {
            this.left = node;
          }
        } else {
          if (this.right) {
            this.right.insert(node);
          } else {
            this.right = node;
          }
        }
        this.height = Math.max(this.left?.height ?? 0, this.right?.height ?? 0) + 1;
        let balance = this.balance;
        if (balance > 1) {
          if (node.data < this.left!.data) {
            this.rightRotate();
          } else {
            this.left!.leftRotate();
            this.rightRotate();
          }
        } else if (balance < -1) {
          if (node.data > this.right!.data) {
            this.leftRotate();
          } else {
            this.right!.rightRotate();
            this.leftRotate();
          }
        }
      }
      remove(data: T): AvlNode<T> | null {
        if (data < this.data) {
          if (this.left) {
            this.left = this.left.remove(data);
          }
        } else if (data > this.data) {
          if (this.right) {
            this.right = this.right.remove(data);
          }
        } else {
          if (!this.left && !this.right) {
            return null;
          } else if (this.left && !this.right) {
            return this.left;
          } else if (!this.left && this.right) {
            return this.right;
          } else {
            let temp = this.right;
            while (temp.left) {
              temp = temp.left;
            }
            this.data = temp.data;
            this.right = this.right!.remove(temp.data);
          }
        }
        this.height = Math.max(this.left?.height ?? 0, this.right?.height ?? 0) + 1;
        let balance = this.balance;
        if (balance > 1) {
          if (this.left!.balance >= 0) {
            this.rightRotate();
          } else {
            this.left!.leftRotate();
            this.rightRotate();
          }
        } else if (balance < -1) {
          if (this.right!.balance <= 0) {
            this.leftRotate();
          } else {
            this.right!.rightRotate();
            this.leftRotate();
          }
        }
        return this;
      }
      find(data: T): AvlNode<T> | null {
        if (data < this.data) {
          if (this.left) {
            return this.left.find(data);
          }
        } else if (data > this.data) {
          if (this.right) {
            return this.right.find(data);
          }
        } else {
          return this;
        }
        return null;
      }
      *ergodic(isReverse?: boolean): Iterable<AvlNode<T>> {
        let temp: AvlNode<T>;
        if (isReverse) {
          temp = this.right!;
          while (temp) {
            yield temp;
            temp = temp.left!;
          }
        } else {
          temp = this.left!;
          while (temp) {
            yield temp;
            temp = temp.right!;
          }
        }
      }
      get balance(): number {
        return (this.left?.height ?? 0) - (this.right?.height ?? 0);
      }
      rightRotate(): void {
        let temp = new AvlNode<T>(this.data);
        temp.left = this.left?.right;
        temp.right = this.right;
        this.data = this.left!.data;
        this.left = this.left?.left;
        this.right = temp;
        this.height = Math.max(this.left?.height ?? 0, this.right?.height ?? 0) + 1;
      }
      leftRotate(): void {
        let temp = new AvlNode<T>(this.data);
        temp.left = this.left;
        temp.right = this.right?.left;
        this.data = this.right!.data;
        this.left = temp;
        this.right = this.right?.right;
        this.height = Math.max(this.left?.height ?? 0, this.right?.height ?? 0) + 1;
      }
    }
    export class AvlTree<T> {
      private root: AvlNode<T> | null;
      constructor() {
        this.root = null;
      }
      insert(data: T): void {
        let temp = new AvlNode<T>(data);
        if (!this.root) {
          this.root = temp;
        } else {
          this.root.insert(temp);
        }
      }
      remove(data: T): void {
        if (!this.root) return;
        this.root = this.root.remove(data);
      }
      find(data: T): AvlNode<T> | null {
        if (!this.root) return null;
        return this.root.find(data);
      }
      ergodic(isReverse?: boolean): Iterable<AvlNode<T>> {
        if (!this.root) return [];
        return this.root.ergodic(isReverse);
      }
    }
    /**graph */
    export class GraphNode<T> {
      private _edges: Map<GraphNode<T>, number>;
      constructor(public data: T) {
        this._edges = new Map<GraphNode<T>, number>();
      }
      get edges(): Map<GraphNode<T>, number> {
        return this._edges;
      }
      addEdge(node: GraphNode<T>, weight: number): void {
        this._edges.set(node, weight);
      }
      removeEdge(node: GraphNode<T>): void {
        this._edges.delete(node);
      }
    }
    export class Edge<T> {
      constructor(public from: T, public to: T, public weight: number) {
      }
    }
    export class Graph<T> {
      private _nodes: Map<T, GraphNode<T>>;
      private _edges: Array<Edge<T>>;
      constructor() {
        this._nodes = new Map<T, GraphNode<T>>();
        this._edges = [];
      }
      addNode(data: T): void {
        this._nodes.set(data, new GraphNode<T>(data));
      }
      removeNode(data: T): void {
        this._nodes.delete(data);
        for (let i of this._nodes.values()) {
          i.edges.delete(this._nodes.get(data)!);
        }
      }
      addEdge(from: T, to: T, weight: number): void {
        this._nodes.get(from)?.addEdge(this._nodes.get(to)!, weight);
      }
      removeEdge(from: T, to: T): void {
        this._nodes.get(from)?.removeEdge(this._nodes.get(to)!);
      }
    }
  }

