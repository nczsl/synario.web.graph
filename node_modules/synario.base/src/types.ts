export type Dic<V> = { [key: string]: V };
export type AnsiColor = 'black' | 'red' | 'green' | 'yellow' | 'blue' | 'magenta' | 'cyan' | 'white';
export type AnsiStyle = 'bold' | 'italic' | 'underline' | 'inverse' | 'strikethrough';
export type AnsiBackground = 'bgBlack' | 'bgRed' | 'bgGreen' | 'bgYellow' | 'bgBlue' | 'bgMagenta' | 'bgCyan' | 'bgWhite';
export type FrameHandler = (tick: number) => void;
export interface WebSocketConfig {
  url: string;
  on(this: WebSocket, message: MessageEvent): any;
  onopen?(this: WebSocket, e: Event): void;
  onclose?(this: WebSocket, e: CloseEvent): void;
  onerror?(this: WebSocket, e: Event): void;
}
export type HeaderField = 'Accept' | 'Accept-Charset' | 'Accept-Encoding' | 'Accept-Language' | 'Accept-Ranges' | 'Authorization' | 'Cache-Control' | 'Connection' | 'Cookie' | 'Content-Length' | 'Content-Type' | 'Date' | 'Expect' | 'From' | 'Host' | 'If-Match' | 'If-Modified-Since' | 'If-None-Match' | 'If-Range' | 'If-Unmodified-Since' | 'Max-Forwards' | 'Pragma' | 'Proxy-Authorization' | 'Range' | 'Referer' | 'TE' | 'Upgrade' | 'User-Agent' | 'Via' | 'Warning';
export type RequestHead = { [key in HeaderField]?: string };
export type DataFormat = 'search' | 'form' | 'json' | 'blob' | 'text' | 'buffer';
export type MethodType = 'GET' | 'POST' | 'PUT' | 'DELETE' | 'HEAD' | 'PATCH' | 'OPTIONS';
export type Fetch_Mode = 'no-cors' | 'cors' | 'same-origin';
export type TransmissionTypee = 'form' | 'urlencode' | 'text' | 'json' | 'stream' | 'html' | 'xml';
export type Mime = { [key in TransmissionTypee]?: string };
export interface INetConfig {
  url: string;
  data?: any;
  cache?: RequestCache;
  credentials?: RequestCredentials;
  headers?: RequestHead;
  integrity?: string;
  keepalive?: boolean;
  method?: MethodType;
  mode?: RequestMode;
  redirect?: RequestRedirect;
  referrer?: string;
  referrerPolicy?: ReferrerPolicy;
  format?: DataFormat;
}
export type SortEnum = 'ascending' | 'descending';
export type WhereHandler<Qh> = (item: Qh) => boolean;
export type Include<T, U, K extends PropertyKey> = {
  [P in keyof T]: T[P];
} & { [P in K]: U };
export type SubInt<T extends number, _Arr extends number[] = []> = T extends number
  ? _Arr['length'] extends T
    ? _Arr[number]
    : SubInt<T, [..._Arr, _Arr['length']]>
  : never;
export type UnionToIntersection<T> = (T extends T ? (params: T) => any : never) extends (params: infer P) => any
  ? P
  : never;
export type UnionToTuple<T, Res extends any[] = []> = UnionToIntersection<T extends any ? () => T : never> extends () => infer ReturnType
  ? UnionToTuple<Exclude<T, ReturnType>, [...Res, ReturnType]>
  : Res;
export type Values<T extends Record<string, unknown>> = T extends Record<string, unknown> ? T[keyof T] : never;
export type NonObjectPropKeys<T> = {
  [K in keyof T]: T[K] extends any[] ? K : T[K] extends object ? never : K;
}[keyof T];
export type NonObjectPicks<T> = Pick<T, NonObjectPropKeys<T>>;
export type ObjectPicks<T> = Pick<T, Exclude<keyof T, NonObjectPropKeys<T>>>;
export type Obj<T> = T extends object ? T : never;
export type FlattenObjectKey<T> = T extends any[]
  ? T
  : T extends object
  ? UnionToIntersection<Obj<T[keyof T]>> extends object
    ? NonObjectPicks<T> & FlattenObjectKey<ObjectPicks<T>[keyof ObjectPicks<T>]>
    : T
  : never;
export type LocalDispenserHandlers<T extends Record<string, unknown>> = FlattenObjectKey<T>;


