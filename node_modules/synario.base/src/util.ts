import * as types_mod from './types';

// get guid
export function guid() {
  let dt = new Uint32Array(4);
  crypto.getRandomValues(dt);
  return `${dt[0].toString(16)}-${dt[1].toString(16)}-4${dt[2].toString(16).slice(1)}-${(dt[3] & 0x3 | 0x8).toString(16)}-${dt[0].toString(16)}${dt[1].toString(16)}${dt[2].toString(16)}`.toLowerCase();
}
//#region const string
export const ansi: string = '\x1b[';
export const space: string = ' ';
export const wrap: string = '\n';
export const tab: string = '\t';
//#endregion
//#region sort
export function quickSort(arr: number[], begin: number, end: number): Array<number> {
  if (end <= begin)
    return arr;
  let i = begin;
  let j = end;
  let key = arr[begin];
  while (true) {
    while (true) {
      if (i == j) break;
      if (arr[j] < key) {
        let temp = arr[j];
        arr[j] = arr[i];
        arr[i] = temp;
        break;
      }
      j--;
    }
    while (true) {
      if (i == j) break;
      if (arr[i] > key) {
        let temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
        break;
      }
      i++;
    }
    if (i == j)
      break;
  }
  if (end - j > 1) {
    arr = quickSort(arr, j + 1, end);
  }
  if (i - begin > 1) {
    arr = quickSort(arr, begin, i);
  }
  return arr;
}
/**插入排序 
 * @param:ascendingDescending default is true repersent asscnding else is descending
 */
export function InsertSort(arr: number[], ascendingDescending: boolean = true) {
  if (ascendingDescending) {
    for (let i = 1; i < arr.length; i++) {
      let j = i - 1;
      let temp = arr[i];
      if (arr[j] > temp) {
        while (j >= 0 && arr[j] > temp) {
          arr[j + 1] = arr[j];
          j--;
        }
        arr[j + 1] = temp;
      }
    }
  } else {
    for (let i = 1; i < arr.length; i++) {
      let j = i - 1;
      let temp = arr[i];
      if (arr[j] < temp) {
        while (j >= 0 && arr[j] < temp) {
          arr[j + 1] = arr[j];
          j--;
        }
        arr[j + 1] = temp;
      }
    }
  }
}
export function InsertOrder<T>(arr: T[], compare: (t: T) => number, ascendingDescending: boolean = true) {
  if (ascendingDescending) {
    for (let i = 1; i < arr.length; i++) {
      let j = i - 1;
      let temp = arr[i];
      if (compare(arr[j]) > compare(temp)) {
        while (j >= 0 && compare(arr[j]) > compare(temp)) {
          arr[j + 1] = arr[j];
          j--;
        }
        arr[j + 1] = temp;
      }
    }
  } else {
    for (let i = 1; i < arr.length; i++) {
      let j = i - 1;
      let temp = arr[i];
      if (compare(arr[j]) < compare(temp)) {
        while (j >= 0 && compare(arr[j]) < compare(temp)) {
          arr[j + 1] = arr[j];
          j--;
        }
        arr[j + 1] = temp;
      }
    }
  }
}
// #endregion

//#region ansi
function ansiStartTag(color: types_mod.AnsiColor, styles?: types_mod.AnsiStyle[], background?: types_mod.AnsiBackground): string {
  let result = ansi;
  switch (color) {
    case 'black': result += '30'; break;
    case 'red': result += '31'; break;
    case 'green': result += '32'; break;
    case 'yellow': result += '33'; break;
    case 'blue': result += '34'; break;
    case 'magenta': result += '35'; break;
    case 'cyan': result += '36'; break;
    case 'white': result += '37'; break;
  }
  if (styles) {
    styles.forEach(style => {
      switch (style) {
        case 'bold': result += ';1'; break;
        case 'italic': result += ';3'; break;
        case 'underline': result += ';4'; break;
        case 'inverse': result += ';7'; break;
        case 'strikethrough': result += ';9'; break;
      }
    });
  }
  if (background) {
    switch (background) {
      case 'bgBlack': result += ';40'; break;
      case 'bgRed': result += ';41'; break;
      case 'bgGreen': result += ';42'; break;
      case 'bgYellow': result += ';43'; break;
      case 'bgBlue': result += ';44'; break;
      case 'bgMagenta': result += ';45'; break;
      case 'bgCyan': result += ';46'; break;
      case 'bgWhite': result += ';47'; break;
    }
  }
  return result + 'm';
}
function ansiEndTag(): string {
  return `${ansi}0m`;
}
export function consoleWarn(msg: string): void {
  console.log(ansiStartTag('yellow') + msg + ansiEndTag());
}
export function consoleError(msg: string): void {
  console.log(ansiStartTag('red') + msg + ansiEndTag());
}
export function consoleSuccess(msg: string): void {
  console.log(ansiStartTag('green') + msg + ansiEndTag());
}
export function consoleInfo(msg: string, color: types_mod.AnsiColor, style?: types_mod.AnsiStyle, background?: types_mod.AnsiBackground): void {
  console.log(ansiStartTag(color, [style], background) + msg + ansiEndTag());
}
export function consoleLink(title: string, url: string): void {
  //正则检查url是否合法
  if (!isValidUrl(url)) throw new Error('url is invalid');
  const _titleLength = 50;
  if (title && title.length > _titleLength) throw new Error(`title length must less than ${_titleLength}`);
  let steps: string[] = [];
  steps.push(ansiStartTag('cyan') + title + ansiEndTag());
  steps.push(ansiStartTag('green') + ':' + ansiEndTag());
  steps.push(ansiStartTag('blue', ['underline']) + url + ansiEndTag());
  console.log(steps.join(space));
}
function buildAnsi(msg: string, color: types_mod.AnsiColor, styles?: types_mod.AnsiStyle[], background?: types_mod.AnsiBackground): string {
  return `${ansiStartTag(color, styles, background)}${msg}${ansiEndTag()}`;
}
export function consoleDebug(...objs: any[]): void {
  if (!objs) return;
  let splitchars = /\n|\t|,/;
  let error = new Error();
  let stacks = error.stack?.split(splitchars);
  let stack: string;
  // console.log(stacks);
  if (stacks && stacks.length < 3) {
    stack = stacks[0];
  } else {
    stack = stacks ? stacks[2] : '';
  }
  stack = stack.trim();
  //仅提取括号内的内容
  let reg = /at\s\b([\w\s?\.]+)\b\s?\(([^)\s]+)\)/;
  let match = reg.exec(stack);
  let _path = match ? match[2] : '';
  let _target = match ? match[1] : '';
  let prefix = [buildAnsi(_path, 'blue', ['italic', 'underline']), buildAnsi(_target, 'magenta', ['italic']), buildAnsi(dateFormat('DDhhmmss', new Date()), 'blue', ['italic']), buildAnsi('>>', 'cyan', ['italic']), space].join(space);
  let _msg: string;
  if (objs.length == 1 && JSON.stringify(objs[0]).length < 49) {
    _msg = printObject(objs[0]);
  } else {
    _msg = objs.map(i => printObject(i)).join(space);
  }
  console.log(`${prefix}${_msg}`);
}
/**
 * 需要传入参数为偶数且大于等于2，将偶数位视为key，奇数位视为value
 */
export function consoleDebugKv(...objs: any[]): void {
  if (!objs) return;
  if (objs.length % 2 != 0 || objs.length < 2) {
    consoleDebug(...objs);
    return;
  }
  let splitchars = /\n|\t|,/;
  let error = new Error();
  let stacks = error.stack?.split(splitchars);
  // console.log('stacks', stacks);
  let stack: string;
  if (stacks && stacks.length < 3) {
    stack = stacks[0];
  } else {
    stack = stacks ? stacks[2] : '';
  }
  stack = stack.trim();
  // console.log(stack);
  //仅提取括号内的内容
  let reg = /at\s\b([\w\s?\.]+)\b\s?\(([^)\s]+)\)/;
  let match = reg.exec(stack);
  let _path = match ? match[2] : '';
  let _target = match ? match[1] : '';
  let prefix = [buildAnsi(_path, 'blue', ['underline']), buildAnsi(_target, 'magenta', ['italic']), buildAnsi(dateFormat('DDhhmmss', new Date()), 'blue', ['italic']), buildAnsi('>>', 'cyan', ['italic']), space].join(space);
  let _msg: string;
  let spliter = buildAnsi(' : ', 'magenta', ['italic']);
  if (objs.length == 2 && (JSON.stringify(objs[0]).length + JSON.stringify(objs[1]).length) < 49) {
    _msg = [buildAnsi(objs[0], 'black', ['italic'], 'bgWhite'), buildAnsi(printObject(objs[1]), 'black', ['italic'])].join(spliter);
  } else {
    let msg2: string[] = [];
    for (let i = 0; i < objs.length; i += 2) {
      msg2.push([buildAnsi(objs[i], 'black', ['italic'], 'bgWhite'), buildAnsi(printObject(objs[i + 1]), 'black', ['italic'])].join(spliter));
    }
    _msg = msg2.join('\n');
    _msg = '\n' + _msg;
  }
  // console.log(_msg);
  console.log(`${prefix}${_msg}`);
}
/**只序列化表层 */
function printObject(obj: any): string {
  if (!obj) return;
  let r: string = '';
  if (obj instanceof String || typeof obj === 'string') {
    r = buildAnsi(obj.toString(), 'white', ['italic']);
  } else if (obj instanceof Number || obj instanceof Boolean || typeof obj === 'number') {
    r = buildAnsi(obj.toString(), 'cyan', ['italic']);
  } else if (obj instanceof Array) {
    r = buildAnsi('[', 'cyan', ['italic']);
    let vs: string[] = [];
    for (let i = 0; i < obj.length; i++) {
      vs.push(printObject(obj[i]) + ',');
    }
    vs.unshift('');//加入此行代码是为了解决在vs.join拼接时会丢失第一个元素的ansi 样式问题
    r += vs.join(space);
    r += buildAnsi(']', 'cyan', ['italic']);
  }
  else if (obj instanceof Object) {
    let vs: string[] = [];
    vs.push(buildAnsi('{', 'cyan', ['italic']));
    for (let key in obj) {
      if (obj[key])
        vs.push(
          buildAnsi(key, 'white', ['italic'])
          + buildAnsi(':', 'white', ['italic'])
          + buildAnsi(obj[key].toString(), 'green', ['italic'])
          + ','
        );
    }
    vs.push(buildAnsi('}', 'cyan', ['italic']));
    vs.unshift(ansiEndTag());//加入此行代码是为了解决在vs.join拼接时会丢失第一个元素的ansi 样式问题
    r += vs.join(space);
  } else {
    r = buildAnsi(obj.toString(), 'red', ['italic']);
  }
  // console.log(r);
  return r;
}
//#endregion
//
export function isValidUrl(str: string) {
  const pattern = /((([A-Za-z]{3,9}:(?:\/\/)?)(?:[\-;:&=\+\$,\w]+@)?[A-Za-z0-9\.\-]+|(?:www\.|[\-;:&=\+\$,\w]+@)[A-Za-z0-9\.\-]+)((?:\/[\+~%\/\.\w\-_]*)?\??(?:[\-\+=&;%@\.\w_]*)#?(?:[\.\!\/\\\w]*))?)/;
  const reg = new RegExp(pattern);
  return reg.test(str);
}

export function clone<T>(obj: T): T {
  let objjson = JSON.stringify(obj);
  return JSON.parse(objjson) as T;
}
/**
 * 将16进制颜色转换成归一化的rgba
 */
export function color2rgba(color: string): { r: number, g: number, b: number, a: number } {
  if (!color.startsWith('#') && color.indexOf('rgb') == -1) throw new Error('color must start with # or rgb');
  const total = 255;
  if (color.startsWith('rgb')) {
    //通过正则表达式获取rgb的值
    color = color.replace(/\s/g, '');
    let result = color.match(/rgb\((\d+),(\d+),(\d+)\)/);
    if (result) {
      let r = parseInt(result[1]) / total;
      let g = parseInt(result[2]) / total;
      let b = parseInt(result[3]) / total;
      return { r, g, b, a: 1 };
    }
    throw new Error('rgb color format error');
  } else {
    if (color.length != 7 && color.length != 4) throw new Error('color length must be 4 or 7');
    if (color.length == 4) {
      color = color.replace(/(\w)(\w)(\w)/, '#$1$1$2$2$3$3');
    }
    let r = parseInt(color.slice(1, 3), 16) / total;
    let g = parseInt(color.slice(3, 5), 16) / total;
    let b = parseInt(color.slice(5, 7), 16) / total;
    return { r, g, b, a: 1 };
  }

}
/*将任意数字映射成一个字符串，映射规则是26个字母，将
传入数字26进制转换，然后再进行与小写字母的映射
*/
export function nextStringMark(no: number): string {
  let chars = new Array<string>()
  let last = no % 26;
  chars.push(No2Str(last));
  let temp = no;
  while (temp > 25) {
    temp = Math.floor(temp / 26);
    chars.push(No2Str(temp % 26));
  }
  return chars.reverse().join('');
}
// let x:SubInt<10>;
// let x:SubInt<string>;
// type Range<N extends number, A extends any[] = []> = A['length'] extends N
//   ? A[number]
//   : Range<N, [...A, A['length']]>;
export function No2Str(no: number): string {
  let r: string = ''
  no = no % 26;
  no = no + 97;
  r = String.fromCharCode(no);
  return r;
}

export function Round(value: number, significant: number = 2): number {
  return Math.round(value * Math.pow(10, significant)) / Math.pow(10, significant);
}
let mday = new Array(31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31);
/**返回指定年月的天数，注意，月的取值范围是1-12
 * 返回指定月的天数，和其上个月的天数，是一个元组
 * 第一个元素为上个月的天数，第二个元素为指定当月天数
*/
export function GetMonthDay(year: number, month: number): [number, number] {
  if ((year % 40 == 0 && year % 100 != 0) || year % 400 == 0) {//判断是否是闰月
    mday[1] = 29;
  }
  return [mday[month - 1 > 0 ? month - 1 : 11], mday[month]];
}
/**
 *把一维数组转换为指定长度的二维数组
 返回转化后的数组是新数组。原1维数组不受影响
 * @param num 2维数组中的元素数组的长度
 * @param arr 要转化的1维数组
 */
export function Array1To2<T>(num: number, arr: Array<T>): T[][] { // 一维数组转换为二维数组
  const iconsArr: T[][] = []; // 声明数组
  arr.forEach((item, index) => {
    const len = Math.floor(index / num); // 计算该元素为第几个素组内
    if (!iconsArr[len]) { // 判断是否存在
      iconsArr[len] = [];
    }
    iconsArr[len].push(item);
  });
  return iconsArr;
}

export type EventName = 'onitems' | 'oncontent';
export function dataBinding(ele: Element, bindEvent: EventName, data: any): CustomEvent<any> {
  let x = new CustomEvent<any>(bindEvent, { 'detail': data });
  ele.dispatchEvent(x);
  return x;
}
export function dataBindings(eles: Element[], bindEvent: EventName, data: any): CustomEvent<any> {
  let x = new CustomEvent<any>(bindEvent, { 'detail': data });
  eles.forEach(i => i.dispatchEvent(x));
  return x;
}
/**键为string的字典，使用示例： let x:Dic<number>={} x['a']=0;x['b']=11;console.log(x['a'])//0 */
export let tempData: types_mod.Dic<any> = {};
export function clearTemp() {
  tempData = {};
}
function dateFormat(fmt: string, date: Date): string {
  const opt: { [key: string]: string } = {
    "Y+": date.getFullYear().toString(),
    "M+": (date.getMonth() + 1).toString(),
    "D+": date.getDate().toString(),
    "h+": date.getHours().toString(),
    "m+": date.getMinutes().toString(),
    "s+": date.getSeconds().toString()
  };
  for (let k in opt) {
    fmt = fmt.replace(new RegExp('(' + k + ')', 'g'), match =>
      match.length === 1 ? opt[k] : opt[k].padStart(match.length, '0')
    );
  }
  return fmt;
}
/**获取当前时间 */
export function getNow(): string {
  let date = new Date();
  return `${date.getFullYear()}/${date.getMonth() + 1}/${date.getDate()}T${date.getHours()}:${date.getMinutes()}:${date.getSeconds()}`;
}
/**如果存在则删除，否则无操作 */
export function removeElement(ele: HTMLElement): void {
  if (ele) {
    ele.parentNode?.removeChild(ele);
  }
}
function getBrowerInfo(): { n: string, v: string } {
  let n = navigator.userAgent.toLowerCase();
  // let v = navigator.appVersion.toLowerCase();
  let v = navigator.userAgent.toLowerCase();
  return { n, v };
}
export function checkGrid(): boolean {
  let r = false;
  let { n, v } = getBrowerInfo();
  console.log({ n, v });
  let temp = v.split('.')[0];
  let vx = parseInt(temp);
  let checks = ['chrome', 'firefox', 'trident', 'edge', 'opr', 'safari', 'macintosh'];
  if (n == checks[0] && vx >= 57) r = true;
  else if (n == checks[1] && vx >= 52) r = true;
  else if (n == checks[2] && vx >= 10) r = true;
  else if (n == checks[3] && vx >= 16) r = true;
  else if (n == checks[4] && vx >= 44) r = true;
  else if (n == checks[5] && vx >= 11) r = true;
  return r;
}

export function splitBigInt(num: number): [number, number] {
  const highBits = (num / Math.pow(2, 32)) | 0;
  const lowBits = num | 0;
  return [highBits, lowBits];
}

export function mergeBigInt(high: number, low: number): number {
  return high * Math.pow(2, 32) + low;
}

export function sleep(ms: number) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

export const keyCodeMap: { [key: string]: number } = {
  'Digit0': 0x30, 'Digit1': 0x31, 'Digit2': 0x32, 'Digit3': 0x33, 'Digit4': 0x34,
  'Digit5': 0x35, 'Digit6': 0x36, 'Digit7': 0x37, 'Digit8': 0x38, 'Digit9': 0x39,
  'KeyA': 0x41, 'KeyB': 0x42, 'KeyC': 0x43, 'KeyD': 0x44, 'KeyE': 0x45,
  'KeyF': 0x46, 'KeyG': 0x47, 'KeyH': 0x48, 'KeyI': 0x49, 'KeyJ': 0x4A,
  'KeyK': 0x4B, 'KeyL': 0x4C, 'KeyM': 0x4D, 'KeyN': 0x4E, 'KeyO': 0x4F,
  'KeyP': 0x50, 'KeyQ': 0x51, 'KeyR': 0x52, 'KeyS': 0x53, 'KeyT': 0x54,
  'KeyU': 0x55, 'KeyV': 0x56, 'KeyW': 0x57, 'KeyX': 0x58, 'KeyY': 0x59,
  'KeyZ': 0x5A, 'ArrowUp': 0x26, 'ArrowLeft': 0x25, 'ArrowDown': 0x28, 'ArrowRight': 0x27,
  'Keya': 0x61, 'Keyb': 0x62, 'Keyc': 0x63, 'Keyd': 0x64, 'Keye': 0x65,
  'Keyf': 0x66, 'Keyg': 0x67, 'Keyh': 0x68, 'Keyi': 0x69, 'Keyj': 0x6A,
  'Keyk': 0x6B, 'Keyl': 0x6C, 'Keym': 0x6D, 'Keyn': 0x6E, 'Keyo': 0x6F,
  'Keyp': 0x70, 'Keyq': 0x71, 'Keyr': 0x72, 'Keys': 0x73, 'Keyt': 0x74,
  'Keyu': 0x75, 'Keyv': 0x76, 'Keyw': 0x77, 'Keyx': 0x78, 'Keyy': 0x79,
  'Keyz': 0x7A, 'Space': 0x20, 'Enter': 0x0D, 'Escape': 0x1B, 'Backspace': 0x08,
  'Delete': 0x7F, 'Home': 0x01, 'End': 0x04, 'Insert': 0x02, 'PageUp': 0x03,
  'PageDown': 0x05, 'Tab': 0x09, 'ControlLeft': 0x11, 'ControlRight': 0x11, 'AltLeft': 0x12,
  'F1': 0x70, 'F2': 0x71, 'F3': 0x72, 'F4': 0x73, 'F5': 0x74,
  'F6': 0x75, 'F7': 0x76, 'F8': 0x77, 'F9': 0x78, 'F10': 0x79,
  'NumPad0': 0x60, 'NumPad1': 0x61, 'NumPad2': 0x62, 'NumPad3': 0x63, 'NumPad4': 0x64,
  'NumPad5': 0x65, 'NumPad6': 0x66, 'NumPad7': 0x67, 'NumPad8': 0x68, 'NumPad9': 0x69,
  'AltRight': 0x12, 'ShiftLeft': 0x10, 'ShiftRight': 0x10, 'F11': 0x7A, 'F12': 0x7B,
};
export function keyCode2Uint8(code: string): number {
  return keyCodeMap[code] ?? -1;
}


/**
 * 确保ArrayBuffer符合WebGPU Uniform Buffer的最小大小要求（256字节）
 * @param buffer 原始ArrayBuffer
 * @param minSize 最小字节数，默认为256（WebGPU uniform buffer要求）
 * @returns 调整大小后的ArrayBuffer
 */
export function ensureMinimumBufferSize(buffer: ArrayBufferLike, minSize: number = 256): ArrayBufferLike {
  if (buffer.byteLength >= minSize) {
    return buffer;
  }
  
  // 创建一个新的、符合最小大小要求的ArrayBuffer
  const paddedBuffer = new ArrayBuffer(minSize);
  // 复制原始数据
  new Uint8Array(paddedBuffer).set(new Uint8Array(buffer));
  return paddedBuffer;
}
