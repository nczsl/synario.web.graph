export function uuid(): string {
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
    var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
    return v.toString(16);
  }).toUpperCase();
}

//生成从minNum到maxNum的随机数
// export function randomNum(minNum:number, maxNum:number):number {
//   return Math.random() * (maxNum - minNum + 1) + minNum;
// } 
/**
 * 返回生成随机数 通常为10位整数 基于window.crypto.getRandomValues()
*/
export function randomNum(): number {
  return window.crypto.getRandomValues(new Uint32Array(1))[0];
}


/**
 * encode string value to utf-8 conding
 * @param str string value
 * @returns utf-8 string
 */
export function encode(str: string): Uint8Array {
  return new TextEncoder().encode(str);
}

/**
 * decode  to string value,default format is ascii
 * @param buffer is a ArrayBuffer object
 * @param format default is ascii; other select likt utf-8,unicode,gbk,utf-16... etc
 * @returns string value
 */
export function decode(buffer: ArrayBuffer, format: string = 'ascii'): string {
  return new TextDecoder(format).decode(buffer);
}

/**
 * ecdh 密钥交换算法,主要参数为:namedCurve='p-256' ,协商算法采用 aes-cbc length=128
 * ecdh 公钥导出格式为,raw
 * ```
 * //demo：
    let prot1=new util.EcdhSecurity();
    let prot2=new util.EcdhSecurity();
    let keybuffer1=await prot1.exportKey();
    let keybuffer2=await prot2.exportKey();
    console.log(keybuffer1,keybuffer2);
    await prot2.importKey(keybuffer1);
    await prot1.importKey(keybuffer2);
    let cipherobj=await prot1.encrypt('hello ...');
    let plaintext=await prot2.decrypt(cipherobj);
    console.log(plaintext);
    console.log(cipherobj.buffer);
    console.log(util.decode(cipherobj.buffer));
 * ```
 */
export class EcdhSecurity {
  generateIv(): Uint8Array {
    return crypto.getRandomValues(new Uint8Array(16));
  }
  private key?: CryptoKeyPair;
  private sessionkey?: CryptoKey;
  /**
   * @see https://github.com/mdn/dom-examples/blob/master/web-crypto/derive-bits/ecdh.js
   */
  private async generateKey() {
    let keyUsages: KeyUsage[] = ['deriveKey', 'deriveBits'];
    this.key = await window.crypto.subtle.generateKey(
      { name: 'ECDH', namedCurve: 'P-256' },
      false,
      keyUsages
    );
  }
  async exportKey(): Promise<Uint8Array> {
    await this.generateKey();
    let keyobj = await window.crypto.subtle.exportKey('raw', this.key!.publicKey);
    return new Uint8Array(keyobj);
  }
  async importKey(keyobj: Uint8Array): Promise<void> {
    let remotekey = await window.crypto.subtle.importKey('raw', keyobj, { name: 'ECDH', namedCurve: 'P-256' }, false, []);
    await this.setRemotePublicKey(remotekey);
  }
  async encrypt(plaintext: string): Promise<{ buffer: ArrayBuffer, iv: Uint8Array }> {
    let iv = this.generateIv();
    const buffer = await crypto.subtle.encrypt({
      name: 'AES-CBC',
      iv,
      length: 128
    }, this.sessionkey!, encode(plaintext));
    return { buffer, iv };
  }

  async decrypt(data: { buffer: ArrayBuffer, iv: Uint8Array }): Promise<string> {
    const buffer = await crypto.subtle.decrypt({
      name: 'AES-CBC',
      iv: data.iv,
      length: 128
    }, this.sessionkey!, data.buffer);
    return decode(buffer);
  }

  // clientKey: CryptoKey;
  // sharedSecret:ArrayBuffer;
  private async setRemotePublicKey(remotekey: CryptoKey) {
    // this.sharedSecret = await window.crypto.subtle.deriveBits(
    //   { name: 'ECDH', public: remotekey },
    //   this.key.privateKey,
    //   256
    // );
    // this.derivekey = await crypto.subtle.importKey(
    //   'raw',
    //   this.sharedSecret,
    //   'AES-CBC',
    //   false,
    //   ['encrypt', 'decrypt']
    // );
    //上面注释的内容与下面的内容作用相同
    this.sessionkey = await crypto.subtle.deriveKey(
      { name: 'ECDH', public: remotekey },
      this.key!.privateKey,
      { name: 'AES-CBC', length: 128 },
      false,
      ['encrypt', 'decrypt']
    );
  }
}

