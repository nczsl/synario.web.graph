//version: 2023.04.30
import * as types_mod from './types';
import * as collections_mod from './collections';

export class Netcon {
  mime!: types_mod.Mime;
  constructor() {
    this.initmime();
  }
  private toHeaders(h: types_mod.RequestHead): HeadersInit {
    let hh: HeadersInit = new Headers();
    for (let i in h) {
      let x = <types_mod.HeaderField>i;
      hh.append(i, h[x] as string);
    }
    return hh;
  }
  /**
   * let fd=new FormData();
   * configfIns.body=fd.
   * let x:BodyInit;
   * let x2=new Blob()
   * let x3=new URLSearchParams('a=xx1&b=xx2')
   * x2.size()
   * Blob | BufferSource | FormData | URLSearchParams | ReadableStream<Uint8Array> | string
   * @param data 
   * @param format 
   */
  private toFetchBody(data: any, format: types_mod.DataFormat): BodyInit {
    switch (format) {
      case "search":
        return this.toSearch(data);
      case "form":
        return this.toForm(data);
      case "json":
        return JSON.stringify(data);
      case "blob":
        return this.toBlob(data);
      case "buffer":
        return this.toBuffer(data);
      case "text":
        return data ? <string>data : '';
    }
  }
  private toBuffer(data: any): ArrayBuffer {
    // console.log('->instanceof Uint8Array', data instanceof Uint8Array);
    if (data instanceof ArrayBuffer) return data;
    else if (data instanceof Uint8Array) return data.buffer as ArrayBuffer;
    else if (data instanceof Uint16Array) return data.buffer as ArrayBuffer;
    else if (data instanceof Uint32Array) return data.buffer as ArrayBuffer;
    else if (data instanceof Int8Array) return data.buffer as ArrayBuffer;
    else if (data instanceof Int16Array) return data.buffer as ArrayBuffer;
    else if (data instanceof Int32Array) return data.buffer as ArrayBuffer;
    else if (data instanceof Float32Array) return data.buffer as ArrayBuffer;
    else if (data instanceof Float64Array) return data.buffer as ArrayBuffer;
    else if (data instanceof BigInt64Array) return data.buffer as ArrayBuffer;
    else if (data instanceof BigUint64Array) return data.buffer as ArrayBuffer;
    else if (data instanceof DataView) return data.buffer as ArrayBuffer;
    else throw new Error('data type error');
  }
  private toBlob(data: any): Blob {
    //data is string
    if (typeof (data) == 'string') {
      return new Blob([data], { type: this.mime.text });
    }
    else if (data instanceof Blob) {
      return data;
    }
    else if (data instanceof ArrayBuffer) {
      return new Blob([data], { type: this.mime.stream });
    }
    else if (data instanceof Uint8Array) {
      // console.log('->Uint8Array');
      return new Blob([data], { type: this.mime.stream });
    }
    else if (Array.isArray(data)) {
      return new Blob(data);
    }
    else if (typeof data == 'object') {
      return new Blob([JSON.stringify(data)], { type: this.mime.json });
    }
    else {
      throw new Error('data type error');
    }
  }
  private toSearch(data: any): URLSearchParams {
    if (typeof (data) == 'number') {
      return new URLSearchParams(`id=${data}`);
    }
    if (typeof (data) == 'string') {
      let pattern = /\?([^?&+=]*=[^?&+=]*\&?)*/g;
      let arr = data.match(pattern);
      if (arr) {
        let s = new URLSearchParams(arr[0]);
        return s;
      }
      else {
        return new URLSearchParams(`?content=${data}`);
      }
    }
    if (data instanceof URLSearchParams) return data;
    let r: URLSearchParams = new URLSearchParams();
    for (let i in data) {
      if (Array.isArray(data[i])) {
        r.append(i, `[${data[i].join(',')}]`);
      } else if (typeof data[i] == 'string' || typeof data[i] == 'number' || typeof data[i] == 'boolean' || data[i] instanceof Date) {
        r.append(i, String(data[i]));
      }
    }
    return r;
  }
  private toForm(data: any): FormData {
    if (data instanceof FormData) return data;
    if (data instanceof HTMLFormElement) return new FormData(data);
    let fd: FormData = new FormData();
    if (data) {
      for (let i in data) {
        if (typeof data[i] == 'string' || typeof data[i] == 'number' || typeof data[i] == 'boolean' || data[i] instanceof Date || data[i] instanceof Blob) {
          fd.append(i, String(data[i]));
        }
        else if (typeof data[i] == 'object') {
          // for(let j in data[i]){
          //   fd.append(`${i}[${j}]`,String(data[i][j]));
          // }
          // 用递归的方式处理
          let temp = data[i];
          let keys = Object.keys(temp);
          for (let j = 0; j < keys.length; j++) {
            this.toForm({ [`${i}[${keys[j]}]`]: temp[keys[j]] }).forEach((v, k) => {
              fd.append(k, v);
            });
          }
        }
      }
    }
    return fd;
  }
  private setContentType(head: types_mod.RequestHead, format?: types_mod.DataFormat): void {
    if (!format) format = 'search';
    switch (format) {
      case 'search':
        head['Content-Type'] = this.mime.urlencode;
        break;
      case 'form':
        /**走form 则请求的header自己不能写了，要通过浏览器或相关系统api自动来写不然会报boundary错误
         * 因为这个值没法正确设置只能由系统自动根据FormData来设置
         * post 请求上传文件的时候是不需要自己设置 Content-Type，
         * 会自动给你添加一个 boundary ，用来分割消息主体中的每个字段，如果这个时候自己设置了 
         * Content-Type， 服务器就不知道怎么分割各个字段，因此就会报错
        */
        // head["Content-Type"] = this.mime.form;
        // head["boundary"] = '&';
        break;
      case 'json':
        head['Content-Type'] = this.mime.json;
        break;
      case 'blob':
        head['Content-Type'] = this.mime.stream;
        break;
      case 'text':
        head['Content-Type'] = this.mime.text;
        break;
      case 'buffer':
        head['Content-Type'] = this.mime.stream;
        break;
    }
  }
  private async request(config: types_mod.INetConfig): Promise<Response> {
    return new Promise((resolve, reject) => {
      try {
        let configf = config as types_mod.INetConfig;
        let requestInit: RequestInit = {
          body: null,
          cache: configf.cache,
          credentials: configf.credentials,
          headers: this.toHeaders(configf.headers!),
          integrity: configf.integrity,
          keepalive: configf.keepalive,
          method: configf.method == undefined ? 'GET' : configf.method,
          mode: configf.mode,
          redirect: configf.redirect,
          referrer: configf.referrer,
          referrerPolicy: configf.referrerPolicy,
        }
        if (configf.data) {
          if (!(configf.method == "GET" || configf.method == "HEAD")) {
            requestInit.body = this.toFetchBody(configf.data, configf.format!);
            // console.log('body:',requestInit.body);//ok
          } else {
            configf.url += `?${this.toSearch(configf.data).toString()}`;
          }
        }
        fetch(configf.url, requestInit).then(res => {
          if (!res.ok) {
            console.log('check fetch support status');
            console.error('error', res.statusText);
          }
          resolve(res);
        }).catch(reason => {
          console.log(reason);
        });
      }
      catch (error) {
        console.log('check fetch support status');
        console.error('error:', error);
        reject(error);
      }
    });
  }
  /**
   * ```
   * data 格式:
   * 如果是数字直接在url上拼为 ?id=xxx
   * 如果是字符串，那么如果此字符串本身就是urlform格式则直接使用否则写为?content=xxx
   * 如果是URLSearchParams 则直接返回它
   * 如果是任意对象，则对其进行非递归第一表层的向URLSearchParams的转化后返回
   * ```
   * 返回一般字符串格式的数据
   */
  async getByTextAsync(uri: string, data?: any, jwtToken?: string): Promise<string> {
    let head: types_mod.RequestHead = {};
    this.setContentType(head);
    head["Accept"] = this.mime.text;
    if (jwtToken)
      head['Authorization'] = `Bearer ${jwtToken}`;
    let config: types_mod.INetConfig = {
      url: uri,
      method: 'GET',
      format: 'search',
      headers: head
    }
    if (data) {
      config.data = data;
    }
    let res = await this.request(config);
    return res.text();
  }
  /**
   * ```
   * data 格式:
   * 如果是数字直接在url上拼为 ?id=xxx
   * 如果是字符串，那么如果此字符串本身就是urlform格式则直接使用否则写为?content=xxx
   * 如果是URLSearchParams 则直接返回它
   * 如果是任意对象，则对其进行非递归第一表层的向URLSearchParams的转化后返回
   * ```
   * 返回js 对象T的数据
   */
  async getByJsonAsync<T>(uri: string, data?: any, jwtToken?: string): Promise<T> {
    let head: types_mod.RequestHead = {};
    this.setContentType(head);
    head["Accept"] = this.mime.json;
    if (jwtToken)
      head['Authorization'] = `Bearer ${jwtToken}`;
    let config: types_mod.INetConfig = {
      url: uri,
      method: 'GET',
      format: 'json',
      headers: head
    }
    if (data) {
      config.data = data;
    }
    let res = await this.request(config);
    return res.json() as Promise<T>;
  }
  /**
   * ```
   * data 格式:
   * 如果是数字直接在url上拼为 ?id=xxx
   * 如果是字符串，那么如果此字符串本身就是urlform格式则直接使用否则写为?content=xxx
   * 如果是URLSearchParams 则直接返回它
   * 如果是任意对象，则对其进行非递归第一表层的向URLSearchParams的转化后返回
   * ```
   * 返回ArrayBuffer/Uint8Array
   */
  async getByBufferAsync(uri: string, data?: any, jwtToken?: string): Promise<ArrayBuffer> {
    let head: types_mod.RequestHead = {};
    this.setContentType(head);
    head["Accept"] = this.mime.stream;
    if (jwtToken)
      head['Authorization'] = `Bearer ${jwtToken}`;
    let config: types_mod.INetConfig = {
      url: uri,
      method: 'GET',
      format: 'form',
      headers: head
    }
    if (data) {
      config.data = data;
    }
    let res = await this.request(config);
    return res.arrayBuffer();
  }
  /**
   * ```
   * data 格式:
   * 如果是数字直接在url上拼为 ?id=xxx
   * 如果是字符串，那么如果此字符串本身就是urlform格式则直接使用否则写为?content=xxx
   * 如果是URLSearchParams 则直接返回它
   * 如果是任意对象，则对其进行非递归第一表层的向URLSearchParams的转化后返回
   * ```
   * 返回Blob格式数据
   */
  async getByBlobAsync(uri: string, data?: any, jwtToken?: string): Promise<Blob> {
    let head: types_mod.RequestHead = {};
    this.setContentType(head);
    head["Accept"] = this.mime.stream;
    if (jwtToken)
      head['Authorization'] = `Bearer ${jwtToken}`;
    let config: types_mod.INetConfig = {
      url: uri,
      method: 'GET',
      headers: head
    }
    if (data) {
      config.data = data;
    }
    let res = await this.request(config);
    return res.blob();
  }
  /**
   * ```
   * 由于getByXXX 的上传参数统一在url中
   * 所以在postByXXX里的data参数是指代这里XXX的类型
   * 和getByXXX的XXX意思有所不同postByXXX中的XXX表示上传
   * ```
   * 此函数的上传数据格式为string
   */
  async postByTextAsync(uri: string, data: string, jwtToken?: string): Promise<Response> {
    let head: types_mod.RequestHead = {};
    let format: types_mod.DataFormat = 'text';
    this.setContentType(head, format);
    if (jwtToken)
      head['Authorization'] = `Bearer ${jwtToken}`;
    let config: types_mod.INetConfig = {
      url: uri,
      method: 'POST',
      format: format,
      headers: head
    }
    config.data = data;
    let res = await this.request(config);
    return res;
  }
  /**
   * ```
   * 由于getByXXX 的上传参数统一在url中，
   * 所以在postByXXX里的data参数是指代这里XXX的类型
   * 和getByXXX的XXX意思有所不同postByXXX中的XXX表示上传
   * ...
   * @param data:类型any 分为几种情况
   * 1，FormData 则直接使用
   * 2，<form> 元素，则直接使用 new FormData(theform);
   * 3，为某类型时，则遍历它的键字对，依次转换为构造的FormData中
   * 的字段键值，对象可是复杂对象即对象字段可为对象 *注意没有对数组类型的处理
   * ```
   * 此函数的上传数据格式为FormData|HTMLFormElement|Object
   */
  async postByFormAsync<T extends FormData | HTMLFormElement | Object>(uri: string, data: T, jwtToken?: string): Promise<Response> {
    let head: types_mod.RequestHead = {};
    let format: types_mod.DataFormat = 'form';
    this.setContentType(head, format);
    if (jwtToken)
      head['Authorization'] = `Bearer ${jwtToken}`;
    let config: types_mod.INetConfig = {
      url: uri,
      method: 'POST',
      format: format,
      headers: head
    }
    config.data = data;
    let res = await this.request(config);
    return res;
  }
  /**
   * ```
   * 由于getByXXX 的上传参数统一在url中，
   * 所以在postByXXX里的data参数是指代这里XXX的类型
   * 和getByXXX的XXX意思有所不同postByXXX中的XXX表示上传
   * ```
   * 此函数的上传数据格式为json
   */
  async postByJsonAsync<T>(uri: string, data: T, jwtToken?: string): Promise<Response> {
    let head: types_mod.RequestHead = {};
    let format: types_mod.DataFormat = 'json';
    this.setContentType(head, format);
    if (jwtToken)
      head['Authorization'] = `Bearer ${jwtToken}`;
    let config: types_mod.INetConfig = {
      url: uri,
      method: 'POST',
      format: format,
      headers: head
    }
    config.data = data;
    let res = await this.request(config);
    return res;
  }

  /**
   * ```
   * 由于getByXXX 的上传参数统一在url中，
   * 所以在postByXXX里的data参数是指代这里XXX的类型
   * 和getByXXX的XXX意思有所不同postByXXX中的XXX表示上传
   * ```
   * 此函数的上传数据格式为ArrayBuffer/Uint8Array
   */
  async postByBufferAsync(uri: string, data: ArrayBuffer | Uint8Array | DataView, jwtToken?: string): Promise<Response> {
    let head: types_mod.RequestHead = {};
    let format: types_mod.DataFormat = 'buffer';
    this.setContentType(head, format);
    if (jwtToken)
      head['Authorization'] = `Bearer ${jwtToken}`;
    let config: types_mod.INetConfig = {
      url: uri,
      method: 'POST',
      format: format,
      headers: head
    }
    config.data = data;
    let res = await this.request(config);
    return res;
  }
  /**
   * ```
   * 由于getByXXX 的上传参数统一在url中，
   * 所以在postByXXX里的data参数是指代这里XXX的类型
   * 和getByXXX的XXX意思有所不同postByXXX中的XXX表示上传
   * @param data: string/Blob/ArrayBuffer/Uint8Array/Array/Object
   * 最适用的直接是元组类型用户可根据需要自由组合[string,number,object]这样
   * ```
   * 此函数的上传数据格式为Blob
   */
  async postByBlobAsync(uri: string, data: any, jwtToken?: string): Promise<Response> {
    let head: types_mod.RequestHead = {};
    let format: types_mod.DataFormat = 'blob';
    this.setContentType(head, format);
    if (jwtToken)
      head['Authorization'] = `Bearer ${jwtToken}`;
    let config: types_mod.INetConfig = {
      url: uri,
      method: 'POST',
      format: format,
      headers: head
    }
    config.data = data;
    let res = await this.request(config);
    return res;
  }
  /**
   * Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36
   * Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:61.0) Gecko/20100101 Firefox/61.0
   * Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.87 Safari/537.36 OPR/54.0.2952.60
   * Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.140 Safari/537.36 Edge/17.17134
   * Mozilla/5.0 (Windows NT 10.0; WOW64; Trident/7.0; .NET4.0C; .NET4.0E; .NET CLR 2.0.50727; .NET CLR 3.0.30729; .NET CLR 3.5.30729; rv:11.0) like Gecko
   * User-Agent:Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_8; en-us) AppleWebKit/534.50 (KHTML, like Gecko) Version/5.1 Safari/534.50
   * */
  getBrowerInfo(): { n: string, v: string } {
    //console.log(navigator);
    let defaultitem = { n: 'nothing', v: '0.0.0000' };
    let ua = "";
    if (typeof (navigator) != 'undefined')
      ua = navigator.userAgent.toLowerCase();
    let pattern = new RegExp('\\w+/(\\d+|\\.)+', 'g');
    let infos = new collections_mod.Store<{ n: string, v: string }>();
    let checks = ['chrome', 'firefox', 'trident', 'edge', 'opr', 'safari', 'macintosh'];
    let temp = ua.match(pattern);
    if (temp == null) return defaultitem;
    temp.forEach((v, i, items) => {
      let it = v.split('/');
      infos.import({ n: it[0], v: it[1] });
    })
    let xs = infos.query().Select<string>(i => i.n);
    // console.log(xs) 
    // console.log(infos)
    if (xs.contains(checks[2])) {
      return infos.query().single(i => {
        let r = false
        if (i != undefined)
          r = i.n == checks[2]
        return r
      })
    } else if (xs.contains(checks[1])) {
      return infos.query().single(i => {
        let r = false
        if (i != undefined)
          r = i.n == checks[1]
        return r
      })
    } else if (xs.contains(checks[3])) {
      return infos.query().single(i => {
        let r = false
        if (i != undefined)
          r = i.n == checks[3]
        return r
      });
    } else if (xs.contains(checks[4])) {
      return infos.query().single(i => {
        let r = false
        if (i != undefined)
          r = i.n == checks[4]
        return r
      });
    } else if (xs.contains(checks[5]) && xs.contains(checks[6])) {
      return infos.query().single(i => {
        let r = false
        if (i != undefined)
          r = i.n == checks[5]
        return r
      });
    } else {
      return infos.query().single(k => {
        let r = false;
        if (k != null)
          r = k.n == checks[0];
        return r;
      });
    }
  }
  private initmime(): void {
    this.mime = {};
    this.mime.form = 'multipart/form-data';
    this.mime.urlencode = 'application/x-www-form-urlencoded';
    this.mime.text = 'text/plain';
    this.mime.json = 'application/json';
    this.mime.html = 'text/html';
    this.mime.stream = 'application/octet-stream';
    this.mime.xml = 'text/xml';
  }
  /**
   */
  /**
   * Opens a WebSocket connection with the given configuration.
   *
   * @param {types_mod.WebSocketConfig} config - The configuration object for the WebSocket connection.
   * @param {string} config.url - The URL to which to connect.
   * @param {function} config.on - The event handler for the `message` event.
   * @param {function} [config.onerror] - The optional event handler for the `error` event.
   * @param {function} [config.onopen] - The optional event handler for the `open` event.
   * @param {function} [config.onclose] - The optional event handler for the `close` event.
   * @returns {WebSocket} The created WebSocket instance.
   */
  openWebSocket(config: types_mod.WebSocketConfig): WebSocket {
    const ws = new WebSocket(config.url);
    ws.onmessage = config.on;
    if (config.onerror) {
      ws.onerror = config.onerror;
    }
    if (config.onopen) {
      ws.onopen = config.onopen;
    }
    if (config.onclose) {
      ws.onclose = config.onclose;
    }
    return ws;
  }
  //
  // checkFetch(): boolean {
  //   let r = false;
  //   let { n, v } = this.getBrowerInfo();
  //   console.log({ n, v });
  //   let temp = v.split('.')[0];
  //   let vx = parseInt(temp);
  //   let checks = ['chrome', 'firefox', 'trident', 'edge', 'opr', 'safari', 'macintosh'];
  //   if (n == checks[0] && vx >= 43) r = true;
  //   else if (n == checks[1] && vx >= 39) r = true;
  //   else if (n == checks[2] && vx >= 12) r = true;
  //   else if (n == checks[3] && vx >= 14) r = true;
  //   else if (n == checks[4] && vx >= 29) r = true;
  //   else if (n == checks[5] && vx >= 11) r = true;
  //   return r;
  // }
}
