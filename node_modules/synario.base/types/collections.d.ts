import * as types_mod from './types';
declare class node<T> {
    data: T;
    right?: node<T>;
    left?: node<T>;
    index: number;
    constructor(data: T);
}
declare class Enumerator<T> {
    head?: node<T>;
    tail?: node<T>;
    _count: number;
    constructor();
    ergodic(isReverse?: boolean): Iterable<node<T>>;
    insert(data: T): void;
    findByIndex(index: number): node<T> | null;
    removeAt(i: number): void;
    updateAtIndex(index: number, newData: T): void;
    dispose(): void;
}
declare class QueryView<Qv> {
    #private;
    private store;
    private source;
    constructor(store: Store<Qv>, source: Enumerator<Qv>);
    container(): boolean;
    valueContainer(): boolean;
    single(predicate: types_mod.WhereHandler<Qv>): Qv;
    get Result(): Array<Qv>;
    private _Iterator;
    predicate?: types_mod.WhereHandler<Qv>;
    ad?: boolean;
    sortor?: (item: Qv) => number;
    Select<Out>(transform: (node: Qv) => Out): SelectView<Qv, Out>;
    GroupBy<Key>(transform: (node: Qv) => Key): GroupView<Qv, Key>;
    OrderBy(sortor: (item: Qv) => number, se?: types_mod.SortEnum): QueryView<Qv>;
}
declare class SelectView<Qv, Sv> {
    private store;
    private owner;
    source?: Array<Qv>;
    transform?: (node: Qv) => Sv;
    constructor(store: Store<Qv>, owner: QueryView<Qv>);
    get Result(): Array<Sv> | undefined;
    contains(i: Sv): boolean;
}
declare class GroupView<Gv, Key> {
    private owner;
    source?: Array<Gv>;
    constructor(owner: QueryView<Gv>);
    transform?: (item: Gv) => Key;
    get Result(): Array<{
        key: Key;
        value: Array<Gv>;
    }>;
}
export declare class Store<T> {
    private source;
    private queryView;
    constructor();
    get count(): number;
    import(it: T | T[]): void;
    dispose(): void;
    query(predicate?: types_mod.WhereHandler<T>): QueryView<T>;
    container<C>(i: C, source: C[]): boolean;
    valueContainer<C>(pridecate: types_mod.WhereHandler<C>, source: C[]): boolean;
    single<C>(pridecate: (i: C) => boolean, s: C[]): C;
}
export declare namespace Set {
    class AvlNode<T> {
        data: T;
        left?: AvlNode<T>;
        right?: AvlNode<T>;
        height: number;
        constructor(data: T);
        insert(node: AvlNode<T>): void;
        remove(data: T): AvlNode<T> | null;
        find(data: T): AvlNode<T> | null;
        ergodic(isReverse?: boolean): Iterable<AvlNode<T>>;
        get balance(): number;
        rightRotate(): void;
        leftRotate(): void;
    }
    class AvlTree<T> {
        private root;
        constructor();
        insert(data: T): void;
        remove(data: T): void;
        find(data: T): AvlNode<T> | null;
        ergodic(isReverse?: boolean): Iterable<AvlNode<T>>;
    }
    class GraphNode<T> {
        data: T;
        private _edges;
        constructor(data: T);
        get edges(): Map<GraphNode<T>, number>;
        addEdge(node: GraphNode<T>, weight: number): void;
        removeEdge(node: GraphNode<T>): void;
    }
    class Edge<T> {
        from: T;
        to: T;
        weight: number;
        constructor(from: T, to: T, weight: number);
    }
    class Graph<T> {
        private _nodes;
        private _edges;
        constructor();
        addNode(data: T): void;
        removeNode(data: T): void;
        addEdge(from: T, to: T, weight: number): void;
        removeEdge(from: T, to: T): void;
    }
}
export {};
