import * as types_mod from './types';
import * as collections_mod from './collections';
export class Netcon {
    mime;
    constructor() {
        this.initmime();
    }
    toHeaders(h) {
        let hh = new Headers();
        for (let i in h) {
            let x = i;
            hh.append(i, h[x]);
        }
        return hh;
    }
    toFetchBody(data, format) {
        switch (format) {
            case "search":
                return this.toSearch(data);
            case "form":
                return this.toForm(data);
            case "json":
                return JSON.stringify(data);
            case "blob":
                return this.toBlob(data);
            case "buffer":
                return this.toBuffer(data);
            case "text":
                return data ? data : '';
        }
    }
    toBuffer(data) {
        if (data instanceof ArrayBuffer)
            return data;
        else if (data instanceof Uint8Array)
            return data.buffer;
        else if (data instanceof Uint16Array)
            return data.buffer;
        else if (data instanceof Uint32Array)
            return data.buffer;
        else if (data instanceof Int8Array)
            return data.buffer;
        else if (data instanceof Int16Array)
            return data.buffer;
        else if (data instanceof Int32Array)
            return data.buffer;
        else if (data instanceof Float32Array)
            return data.buffer;
        else if (data instanceof Float64Array)
            return data.buffer;
        else if (data instanceof BigInt64Array)
            return data.buffer;
        else if (data instanceof BigUint64Array)
            return data.buffer;
        else if (data instanceof DataView)
            return data.buffer;
        else
            throw new Error('data type error');
    }
    toBlob(data) {
        if (typeof (data) == 'string') {
            return new Blob([data], { type: this.mime.text });
        }
        else if (data instanceof Blob) {
            return data;
        }
        else if (data instanceof ArrayBuffer) {
            return new Blob([data], { type: this.mime.stream });
        }
        else if (data instanceof Uint8Array) {
            return new Blob([data], { type: this.mime.stream });
        }
        else if (Array.isArray(data)) {
            return new Blob(data);
        }
        else if (typeof data == 'object') {
            return new Blob([JSON.stringify(data)], { type: this.mime.json });
        }
        else {
            throw new Error('data type error');
        }
    }
    toSearch(data) {
        if (typeof (data) == 'number') {
            return new URLSearchParams(`id=${data}`);
        }
        if (typeof (data) == 'string') {
            let pattern = /\?([^?&+=]*=[^?&+=]*\&?)*/g;
            let arr = data.match(pattern);
            if (arr) {
                let s = new URLSearchParams(arr[0]);
                return s;
            }
            else {
                return new URLSearchParams(`?content=${data}`);
            }
        }
        if (data instanceof URLSearchParams)
            return data;
        let r = new URLSearchParams();
        for (let i in data) {
            if (Array.isArray(data[i])) {
                r.append(i, `[${data[i].join(',')}]`);
            }
            else if (typeof data[i] == 'string' || typeof data[i] == 'number' || typeof data[i] == 'boolean' || data[i] instanceof Date) {
                r.append(i, String(data[i]));
            }
        }
        return r;
    }
    toForm(data) {
        if (data instanceof FormData)
            return data;
        if (data instanceof HTMLFormElement)
            return new FormData(data);
        let fd = new FormData();
        if (data) {
            for (let i in data) {
                if (typeof data[i] == 'string' || typeof data[i] == 'number' || typeof data[i] == 'boolean' || data[i] instanceof Date || data[i] instanceof Blob) {
                    fd.append(i, String(data[i]));
                }
                else if (typeof data[i] == 'object') {
                    let temp = data[i];
                    let keys = Object.keys(temp);
                    for (let j = 0; j < keys.length; j++) {
                        this.toForm({ [`${i}[${keys[j]}]`]: temp[keys[j]] }).forEach((v, k) => {
                            fd.append(k, v);
                        });
                    }
                }
            }
        }
        return fd;
    }
    setContentType(head, format) {
        if (!format)
            format = 'search';
        switch (format) {
            case 'search':
                head['Content-Type'] = this.mime.urlencode;
                break;
            case 'form':
                break;
            case 'json':
                head['Content-Type'] = this.mime.json;
                break;
            case 'blob':
                head['Content-Type'] = this.mime.stream;
                break;
            case 'text':
                head['Content-Type'] = this.mime.text;
                break;
            case 'buffer':
                head['Content-Type'] = this.mime.stream;
                break;
        }
    }
    async request(config) {
        return new Promise((resolve, reject) => {
            try {
                let configf = config;
                let requestInit = {
                    body: null,
                    cache: configf.cache,
                    credentials: configf.credentials,
                    headers: this.toHeaders(configf.headers),
                    integrity: configf.integrity,
                    keepalive: configf.keepalive,
                    method: configf.method == undefined ? 'GET' : configf.method,
                    mode: configf.mode,
                    redirect: configf.redirect,
                    referrer: configf.referrer,
                    referrerPolicy: configf.referrerPolicy,
                };
                if (configf.data) {
                    if (!(configf.method == "GET" || configf.method == "HEAD")) {
                        requestInit.body = this.toFetchBody(configf.data, configf.format);
                    }
                    else {
                        configf.url += `?${this.toSearch(configf.data).toString()}`;
                    }
                }
                fetch(configf.url, requestInit).then(res => {
                    if (!res.ok) {
                        console.log('check fetch support status');
                        console.error('error', res.statusText);
                    }
                    resolve(res);
                }).catch(reason => {
                    console.log(reason);
                });
            }
            catch (error) {
                console.log('check fetch support status');
                console.error('error:', error);
                reject(error);
            }
        });
    }
    async getByTextAsync(uri, data, jwtToken) {
        let head = {};
        this.setContentType(head);
        head["Accept"] = this.mime.text;
        if (jwtToken)
            head['Authorization'] = `Bearer ${jwtToken}`;
        let config = {
            url: uri,
            method: 'GET',
            format: 'search',
            headers: head
        };
        if (data) {
            config.data = data;
        }
        let res = await this.request(config);
        return res.text();
    }
    async getByJsonAsync(uri, data, jwtToken) {
        let head = {};
        this.setContentType(head);
        head["Accept"] = this.mime.json;
        if (jwtToken)
            head['Authorization'] = `Bearer ${jwtToken}`;
        let config = {
            url: uri,
            method: 'GET',
            format: 'json',
            headers: head
        };
        if (data) {
            config.data = data;
        }
        let res = await this.request(config);
        return res.json();
    }
    async getByBufferAsync(uri, data, jwtToken) {
        let head = {};
        this.setContentType(head);
        head["Accept"] = this.mime.stream;
        if (jwtToken)
            head['Authorization'] = `Bearer ${jwtToken}`;
        let config = {
            url: uri,
            method: 'GET',
            format: 'form',
            headers: head
        };
        if (data) {
            config.data = data;
        }
        let res = await this.request(config);
        return res.arrayBuffer();
    }
    async getByBlobAsync(uri, data, jwtToken) {
        let head = {};
        this.setContentType(head);
        head["Accept"] = this.mime.stream;
        if (jwtToken)
            head['Authorization'] = `Bearer ${jwtToken}`;
        let config = {
            url: uri,
            method: 'GET',
            headers: head
        };
        if (data) {
            config.data = data;
        }
        let res = await this.request(config);
        return res.blob();
    }
    async postByTextAsync(uri, data, jwtToken) {
        let head = {};
        let format = 'text';
        this.setContentType(head, format);
        if (jwtToken)
            head['Authorization'] = `Bearer ${jwtToken}`;
        let config = {
            url: uri,
            method: 'POST',
            format: format,
            headers: head
        };
        config.data = data;
        let res = await this.request(config);
        return res;
    }
    async postByFormAsync(uri, data, jwtToken) {
        let head = {};
        let format = 'form';
        this.setContentType(head, format);
        if (jwtToken)
            head['Authorization'] = `Bearer ${jwtToken}`;
        let config = {
            url: uri,
            method: 'POST',
            format: format,
            headers: head
        };
        config.data = data;
        let res = await this.request(config);
        return res;
    }
    async postByJsonAsync(uri, data, jwtToken) {
        let head = {};
        let format = 'json';
        this.setContentType(head, format);
        if (jwtToken)
            head['Authorization'] = `Bearer ${jwtToken}`;
        let config = {
            url: uri,
            method: 'POST',
            format: format,
            headers: head
        };
        config.data = data;
        let res = await this.request(config);
        return res;
    }
    async postByBufferAsync(uri, data, jwtToken) {
        let head = {};
        let format = 'buffer';
        this.setContentType(head, format);
        if (jwtToken)
            head['Authorization'] = `Bearer ${jwtToken}`;
        let config = {
            url: uri,
            method: 'POST',
            format: format,
            headers: head
        };
        config.data = data;
        let res = await this.request(config);
        return res;
    }
    async postByBlobAsync(uri, data, jwtToken) {
        let head = {};
        let format = 'blob';
        this.setContentType(head, format);
        if (jwtToken)
            head['Authorization'] = `Bearer ${jwtToken}`;
        let config = {
            url: uri,
            method: 'POST',
            format: format,
            headers: head
        };
        config.data = data;
        let res = await this.request(config);
        return res;
    }
    getBrowerInfo() {
        let defaultitem = { n: 'nothing', v: '0.0.0000' };
        let ua = "";
        if (typeof (navigator) != 'undefined')
            ua = navigator.userAgent.toLowerCase();
        let pattern = new RegExp('\\w+/(\\d+|\\.)+', 'g');
        let infos = new collections_mod.Store();
        let checks = ['chrome', 'firefox', 'trident', 'edge', 'opr', 'safari', 'macintosh'];
        let temp = ua.match(pattern);
        if (temp == null)
            return defaultitem;
        temp.forEach((v, i, items) => {
            let it = v.split('/');
            infos.import({ n: it[0], v: it[1] });
        });
        let xs = infos.query().Select(i => i.n);
        if (xs.contains(checks[2])) {
            return infos.query().single(i => {
                let r = false;
                if (i != undefined)
                    r = i.n == checks[2];
                return r;
            });
        }
        else if (xs.contains(checks[1])) {
            return infos.query().single(i => {
                let r = false;
                if (i != undefined)
                    r = i.n == checks[1];
                return r;
            });
        }
        else if (xs.contains(checks[3])) {
            return infos.query().single(i => {
                let r = false;
                if (i != undefined)
                    r = i.n == checks[3];
                return r;
            });
        }
        else if (xs.contains(checks[4])) {
            return infos.query().single(i => {
                let r = false;
                if (i != undefined)
                    r = i.n == checks[4];
                return r;
            });
        }
        else if (xs.contains(checks[5]) && xs.contains(checks[6])) {
            return infos.query().single(i => {
                let r = false;
                if (i != undefined)
                    r = i.n == checks[5];
                return r;
            });
        }
        else {
            return infos.query().single(k => {
                let r = false;
                if (k != null)
                    r = k.n == checks[0];
                return r;
            });
        }
    }
    initmime() {
        this.mime = {};
        this.mime.form = 'multipart/form-data';
        this.mime.urlencode = 'application/x-www-form-urlencoded';
        this.mime.text = 'text/plain';
        this.mime.json = 'application/json';
        this.mime.html = 'text/html';
        this.mime.stream = 'application/octet-stream';
        this.mime.xml = 'text/xml';
    }
    openWebSocket(config) {
        const ws = new WebSocket(config.url);
        ws.onmessage = config.on;
        if (config.onerror) {
            ws.onerror = config.onerror;
        }
        if (config.onopen) {
            ws.onopen = config.onopen;
        }
        if (config.onclose) {
            ws.onclose = config.onclose;
        }
        return ws;
    }
}
