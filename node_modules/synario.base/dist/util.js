import * as types_mod from './types';
export function guid() {
    let dt = new Uint32Array(4);
    crypto.getRandomValues(dt);
    return `${dt[0].toString(16)}-${dt[1].toString(16)}-4${dt[2].toString(16).slice(1)}-${(dt[3] & 0x3 | 0x8).toString(16)}-${dt[0].toString(16)}${dt[1].toString(16)}${dt[2].toString(16)}`.toLowerCase();
}
export const ansi = '\x1b[';
export const space = ' ';
export const wrap = '\n';
export const tab = '\t';
export function quickSort(arr, begin, end) {
    if (end <= begin)
        return arr;
    let i = begin;
    let j = end;
    let key = arr[begin];
    while (true) {
        while (true) {
            if (i == j)
                break;
            if (arr[j] < key) {
                let temp = arr[j];
                arr[j] = arr[i];
                arr[i] = temp;
                break;
            }
            j--;
        }
        while (true) {
            if (i == j)
                break;
            if (arr[i] > key) {
                let temp = arr[i];
                arr[i] = arr[j];
                arr[j] = temp;
                break;
            }
            i++;
        }
        if (i == j)
            break;
    }
    if (end - j > 1) {
        arr = quickSort(arr, j + 1, end);
    }
    if (i - begin > 1) {
        arr = quickSort(arr, begin, i);
    }
    return arr;
}
export function InsertSort(arr, ascendingDescending = true) {
    if (ascendingDescending) {
        for (let i = 1; i < arr.length; i++) {
            let j = i - 1;
            let temp = arr[i];
            if (arr[j] > temp) {
                while (j >= 0 && arr[j] > temp) {
                    arr[j + 1] = arr[j];
                    j--;
                }
                arr[j + 1] = temp;
            }
        }
    }
    else {
        for (let i = 1; i < arr.length; i++) {
            let j = i - 1;
            let temp = arr[i];
            if (arr[j] < temp) {
                while (j >= 0 && arr[j] < temp) {
                    arr[j + 1] = arr[j];
                    j--;
                }
                arr[j + 1] = temp;
            }
        }
    }
}
export function InsertOrder(arr, compare, ascendingDescending = true) {
    if (ascendingDescending) {
        for (let i = 1; i < arr.length; i++) {
            let j = i - 1;
            let temp = arr[i];
            if (compare(arr[j]) > compare(temp)) {
                while (j >= 0 && compare(arr[j]) > compare(temp)) {
                    arr[j + 1] = arr[j];
                    j--;
                }
                arr[j + 1] = temp;
            }
        }
    }
    else {
        for (let i = 1; i < arr.length; i++) {
            let j = i - 1;
            let temp = arr[i];
            if (compare(arr[j]) < compare(temp)) {
                while (j >= 0 && compare(arr[j]) < compare(temp)) {
                    arr[j + 1] = arr[j];
                    j--;
                }
                arr[j + 1] = temp;
            }
        }
    }
}
function ansiStartTag(color, styles, background) {
    let result = ansi;
    switch (color) {
        case 'black':
            result += '30';
            break;
        case 'red':
            result += '31';
            break;
        case 'green':
            result += '32';
            break;
        case 'yellow':
            result += '33';
            break;
        case 'blue':
            result += '34';
            break;
        case 'magenta':
            result += '35';
            break;
        case 'cyan':
            result += '36';
            break;
        case 'white':
            result += '37';
            break;
    }
    if (styles) {
        styles.forEach(style => {
            switch (style) {
                case 'bold':
                    result += ';1';
                    break;
                case 'italic':
                    result += ';3';
                    break;
                case 'underline':
                    result += ';4';
                    break;
                case 'inverse':
                    result += ';7';
                    break;
                case 'strikethrough':
                    result += ';9';
                    break;
            }
        });
    }
    if (background) {
        switch (background) {
            case 'bgBlack':
                result += ';40';
                break;
            case 'bgRed':
                result += ';41';
                break;
            case 'bgGreen':
                result += ';42';
                break;
            case 'bgYellow':
                result += ';43';
                break;
            case 'bgBlue':
                result += ';44';
                break;
            case 'bgMagenta':
                result += ';45';
                break;
            case 'bgCyan':
                result += ';46';
                break;
            case 'bgWhite':
                result += ';47';
                break;
        }
    }
    return result + 'm';
}
function ansiEndTag() {
    return `${ansi}0m`;
}
export function consoleWarn(msg) {
    console.log(ansiStartTag('yellow') + msg + ansiEndTag());
}
export function consoleError(msg) {
    console.log(ansiStartTag('red') + msg + ansiEndTag());
}
export function consoleSuccess(msg) {
    console.log(ansiStartTag('green') + msg + ansiEndTag());
}
export function consoleInfo(msg, color, style, background) {
    console.log(ansiStartTag(color, [style], background) + msg + ansiEndTag());
}
export function consoleLink(title, url) {
    if (!isValidUrl(url))
        throw new Error('url is invalid');
    const _titleLength = 50;
    if (title && title.length > _titleLength)
        throw new Error(`title length must less than ${_titleLength}`);
    let steps = [];
    steps.push(ansiStartTag('cyan') + title + ansiEndTag());
    steps.push(ansiStartTag('green') + ':' + ansiEndTag());
    steps.push(ansiStartTag('blue', ['underline']) + url + ansiEndTag());
    console.log(steps.join(space));
}
function buildAnsi(msg, color, styles, background) {
    return `${ansiStartTag(color, styles, background)}${msg}${ansiEndTag()}`;
}
export function consoleDebug(...objs) {
    if (!objs)
        return;
    let splitchars = /\n|\t|,/;
    let error = new Error();
    let stacks = error.stack?.split(splitchars);
    let stack;
    if (stacks && stacks.length < 3) {
        stack = stacks[0];
    }
    else {
        stack = stacks ? stacks[2] : '';
    }
    stack = stack.trim();
    let reg = /at\s\b([\w\s?\.]+)\b\s?\(([^)\s]+)\)/;
    let match = reg.exec(stack);
    let _path = match ? match[2] : '';
    let _target = match ? match[1] : '';
    let prefix = [buildAnsi(_path, 'blue', ['italic', 'underline']), buildAnsi(_target, 'magenta', ['italic']), buildAnsi(dateFormat('DDhhmmss', new Date()), 'blue', ['italic']), buildAnsi('>>', 'cyan', ['italic']), space].join(space);
    let _msg;
    if (objs.length == 1 && JSON.stringify(objs[0]).length < 49) {
        _msg = printObject(objs[0]);
    }
    else {
        _msg = objs.map(i => printObject(i)).join(space);
    }
    console.log(`${prefix}${_msg}`);
}
export function consoleDebugKv(...objs) {
    if (!objs)
        return;
    if (objs.length % 2 != 0 || objs.length < 2) {
        consoleDebug(...objs);
        return;
    }
    let splitchars = /\n|\t|,/;
    let error = new Error();
    let stacks = error.stack?.split(splitchars);
    let stack;
    if (stacks && stacks.length < 3) {
        stack = stacks[0];
    }
    else {
        stack = stacks ? stacks[2] : '';
    }
    stack = stack.trim();
    let reg = /at\s\b([\w\s?\.]+)\b\s?\(([^)\s]+)\)/;
    let match = reg.exec(stack);
    let _path = match ? match[2] : '';
    let _target = match ? match[1] : '';
    let prefix = [buildAnsi(_path, 'blue', ['underline']), buildAnsi(_target, 'magenta', ['italic']), buildAnsi(dateFormat('DDhhmmss', new Date()), 'blue', ['italic']), buildAnsi('>>', 'cyan', ['italic']), space].join(space);
    let _msg;
    let spliter = buildAnsi(' : ', 'magenta', ['italic']);
    if (objs.length == 2 && (JSON.stringify(objs[0]).length + JSON.stringify(objs[1]).length) < 49) {
        _msg = [buildAnsi(objs[0], 'black', ['italic'], 'bgWhite'), buildAnsi(printObject(objs[1]), 'black', ['italic'])].join(spliter);
    }
    else {
        let msg2 = [];
        for (let i = 0; i < objs.length; i += 2) {
            msg2.push([buildAnsi(objs[i], 'black', ['italic'], 'bgWhite'), buildAnsi(printObject(objs[i + 1]), 'black', ['italic'])].join(spliter));
        }
        _msg = msg2.join('\n');
        _msg = '\n' + _msg;
    }
    console.log(`${prefix}${_msg}`);
}
function printObject(obj) {
    if (!obj)
        return;
    let r = '';
    if (obj instanceof String || typeof obj === 'string') {
        r = buildAnsi(obj.toString(), 'white', ['italic']);
    }
    else if (obj instanceof Number || obj instanceof Boolean || typeof obj === 'number') {
        r = buildAnsi(obj.toString(), 'cyan', ['italic']);
    }
    else if (obj instanceof Array) {
        r = buildAnsi('[', 'cyan', ['italic']);
        let vs = [];
        for (let i = 0; i < obj.length; i++) {
            vs.push(printObject(obj[i]) + ',');
        }
        vs.unshift('');
        r += vs.join(space);
        r += buildAnsi(']', 'cyan', ['italic']);
    }
    else if (obj instanceof Object) {
        let vs = [];
        vs.push(buildAnsi('{', 'cyan', ['italic']));
        for (let key in obj) {
            if (obj[key])
                vs.push(buildAnsi(key, 'white', ['italic'])
                    + buildAnsi(':', 'white', ['italic'])
                    + buildAnsi(obj[key].toString(), 'green', ['italic'])
                    + ',');
        }
        vs.push(buildAnsi('}', 'cyan', ['italic']));
        vs.unshift(ansiEndTag());
        r += vs.join(space);
    }
    else {
        r = buildAnsi(obj.toString(), 'red', ['italic']);
    }
    return r;
}
export function isValidUrl(str) {
    const pattern = /((([A-Za-z]{3,9}:(?:\/\/)?)(?:[\-;:&=\+\$,\w]+@)?[A-Za-z0-9\.\-]+|(?:www\.|[\-;:&=\+\$,\w]+@)[A-Za-z0-9\.\-]+)((?:\/[\+~%\/\.\w\-_]*)?\??(?:[\-\+=&;%@\.\w_]*)#?(?:[\.\!\/\\\w]*))?)/;
    const reg = new RegExp(pattern);
    return reg.test(str);
}
export function clone(obj) {
    let objjson = JSON.stringify(obj);
    return JSON.parse(objjson);
}
export function color2rgba(color) {
    if (!color.startsWith('#') && color.indexOf('rgb') == -1)
        throw new Error('color must start with # or rgb');
    const total = 255;
    if (color.startsWith('rgb')) {
        color = color.replace(/\s/g, '');
        let result = color.match(/rgb\((\d+),(\d+),(\d+)\)/);
        if (result) {
            let r = parseInt(result[1]) / total;
            let g = parseInt(result[2]) / total;
            let b = parseInt(result[3]) / total;
            return { r, g, b, a: 1 };
        }
        throw new Error('rgb color format error');
    }
    else {
        if (color.length != 7 && color.length != 4)
            throw new Error('color length must be 4 or 7');
        if (color.length == 4) {
            color = color.replace(/(\w)(\w)(\w)/, '#$1$1$2$2$3$3');
        }
        let r = parseInt(color.slice(1, 3), 16) / total;
        let g = parseInt(color.slice(3, 5), 16) / total;
        let b = parseInt(color.slice(5, 7), 16) / total;
        return { r, g, b, a: 1 };
    }
}
export function nextStringMark(no) {
    let chars = new Array();
    let last = no % 26;
    chars.push(No2Str(last));
    let temp = no;
    while (temp > 25) {
        temp = Math.floor(temp / 26);
        chars.push(No2Str(temp % 26));
    }
    return chars.reverse().join('');
}
export function No2Str(no) {
    let r = '';
    no = no % 26;
    no = no + 97;
    r = String.fromCharCode(no);
    return r;
}
export function Round(value, significant = 2) {
    return Math.round(value * Math.pow(10, significant)) / Math.pow(10, significant);
}
let mday = new Array(31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31);
export function GetMonthDay(year, month) {
    if ((year % 40 == 0 && year % 100 != 0) || year % 400 == 0) {
        mday[1] = 29;
    }
    return [mday[month - 1 > 0 ? month - 1 : 11], mday[month]];
}
export function Array1To2(num, arr) {
    const iconsArr = [];
    arr.forEach((item, index) => {
        const len = Math.floor(index / num);
        if (!iconsArr[len]) {
            iconsArr[len] = [];
        }
        iconsArr[len].push(item);
    });
    return iconsArr;
}
export function dataBinding(ele, bindEvent, data) {
    let x = new CustomEvent(bindEvent, { 'detail': data });
    ele.dispatchEvent(x);
    return x;
}
export function dataBindings(eles, bindEvent, data) {
    let x = new CustomEvent(bindEvent, { 'detail': data });
    eles.forEach(i => i.dispatchEvent(x));
    return x;
}
export let tempData = {};
export function clearTemp() {
    tempData = {};
}
function dateFormat(fmt, date) {
    const opt = {
        "Y+": date.getFullYear().toString(),
        "M+": (date.getMonth() + 1).toString(),
        "D+": date.getDate().toString(),
        "h+": date.getHours().toString(),
        "m+": date.getMinutes().toString(),
        "s+": date.getSeconds().toString()
    };
    for (let k in opt) {
        fmt = fmt.replace(new RegExp('(' + k + ')', 'g'), match => match.length === 1 ? opt[k] : opt[k].padStart(match.length, '0'));
    }
    return fmt;
}
export function getNow() {
    let date = new Date();
    return `${date.getFullYear()}/${date.getMonth() + 1}/${date.getDate()}T${date.getHours()}:${date.getMinutes()}:${date.getSeconds()}`;
}
export function removeElement(ele) {
    if (ele) {
        ele.parentNode?.removeChild(ele);
    }
}
function getBrowerInfo() {
    let n = navigator.userAgent.toLowerCase();
    let v = navigator.userAgent.toLowerCase();
    return { n, v };
}
export function checkGrid() {
    let r = false;
    let { n, v } = getBrowerInfo();
    console.log({ n, v });
    let temp = v.split('.')[0];
    let vx = parseInt(temp);
    let checks = ['chrome', 'firefox', 'trident', 'edge', 'opr', 'safari', 'macintosh'];
    if (n == checks[0] && vx >= 57)
        r = true;
    else if (n == checks[1] && vx >= 52)
        r = true;
    else if (n == checks[2] && vx >= 10)
        r = true;
    else if (n == checks[3] && vx >= 16)
        r = true;
    else if (n == checks[4] && vx >= 44)
        r = true;
    else if (n == checks[5] && vx >= 11)
        r = true;
    return r;
}
export function splitBigInt(num) {
    const highBits = (num / Math.pow(2, 32)) | 0;
    const lowBits = num | 0;
    return [highBits, lowBits];
}
export function mergeBigInt(high, low) {
    return high * Math.pow(2, 32) + low;
}
export function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}
export const keyCodeMap = {
    'Digit0': 0x30, 'Digit1': 0x31, 'Digit2': 0x32, 'Digit3': 0x33, 'Digit4': 0x34,
    'Digit5': 0x35, 'Digit6': 0x36, 'Digit7': 0x37, 'Digit8': 0x38, 'Digit9': 0x39,
    'KeyA': 0x41, 'KeyB': 0x42, 'KeyC': 0x43, 'KeyD': 0x44, 'KeyE': 0x45,
    'KeyF': 0x46, 'KeyG': 0x47, 'KeyH': 0x48, 'KeyI': 0x49, 'KeyJ': 0x4A,
    'KeyK': 0x4B, 'KeyL': 0x4C, 'KeyM': 0x4D, 'KeyN': 0x4E, 'KeyO': 0x4F,
    'KeyP': 0x50, 'KeyQ': 0x51, 'KeyR': 0x52, 'KeyS': 0x53, 'KeyT': 0x54,
    'KeyU': 0x55, 'KeyV': 0x56, 'KeyW': 0x57, 'KeyX': 0x58, 'KeyY': 0x59,
    'KeyZ': 0x5A, 'ArrowUp': 0x26, 'ArrowLeft': 0x25, 'ArrowDown': 0x28, 'ArrowRight': 0x27,
    'Keya': 0x61, 'Keyb': 0x62, 'Keyc': 0x63, 'Keyd': 0x64, 'Keye': 0x65,
    'Keyf': 0x66, 'Keyg': 0x67, 'Keyh': 0x68, 'Keyi': 0x69, 'Keyj': 0x6A,
    'Keyk': 0x6B, 'Keyl': 0x6C, 'Keym': 0x6D, 'Keyn': 0x6E, 'Keyo': 0x6F,
    'Keyp': 0x70, 'Keyq': 0x71, 'Keyr': 0x72, 'Keys': 0x73, 'Keyt': 0x74,
    'Keyu': 0x75, 'Keyv': 0x76, 'Keyw': 0x77, 'Keyx': 0x78, 'Keyy': 0x79,
    'Keyz': 0x7A, 'Space': 0x20, 'Enter': 0x0D, 'Escape': 0x1B, 'Backspace': 0x08,
    'Delete': 0x7F, 'Home': 0x01, 'End': 0x04, 'Insert': 0x02, 'PageUp': 0x03,
    'PageDown': 0x05, 'Tab': 0x09, 'ControlLeft': 0x11, 'ControlRight': 0x11, 'AltLeft': 0x12,
    'F1': 0x70, 'F2': 0x71, 'F3': 0x72, 'F4': 0x73, 'F5': 0x74,
    'F6': 0x75, 'F7': 0x76, 'F8': 0x77, 'F9': 0x78, 'F10': 0x79,
    'NumPad0': 0x60, 'NumPad1': 0x61, 'NumPad2': 0x62, 'NumPad3': 0x63, 'NumPad4': 0x64,
    'NumPad5': 0x65, 'NumPad6': 0x66, 'NumPad7': 0x67, 'NumPad8': 0x68, 'NumPad9': 0x69,
    'AltRight': 0x12, 'ShiftLeft': 0x10, 'ShiftRight': 0x10, 'F11': 0x7A, 'F12': 0x7B,
};
export function keyCode2Uint8(code) {
    return keyCodeMap[code] ?? -1;
}
