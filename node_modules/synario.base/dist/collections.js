import * as types_mod from './types';
import * as util_mod from './util';
class node {
    data;
    right;
    left;
    index;
    constructor(data) {
        this.data = data;
        this.index = -1;
    }
}
class Enumerator {
    head;
    tail;
    _count;
    constructor() {
        this._count = 0;
    }
    *ergodic(isReverse) {
        let temp;
        if (isReverse) {
            temp = this.tail;
            while (temp) {
                yield temp;
                temp = temp.left;
            }
        }
        else {
            temp = this.head;
            while (temp) {
                yield temp;
                temp = temp.right;
            }
        }
    }
    insert(data) {
        let temp = new node(data);
        if (!this.head) {
            this.head = this.tail = temp;
        }
        else {
            this.tail.right = temp;
            temp.left = this.tail;
            this.tail = temp;
        }
        temp.index = this._count;
        this._count++;
    }
    findByIndex(index) {
        let target = null;
        for (let i of this.ergodic()) {
            if (i.index == index) {
                target = i;
                break;
            }
        }
        return target;
    }
    removeAt(i) {
        let target = this.findByIndex(i);
        if (!target)
            return;
        if (target.left) {
            target.left.right = target.right;
        }
        else if (target.right) {
            this.head = target.right;
        }
        if (target.right) {
            target.right.left = target.left;
            let temp = target.right;
            while (temp) {
                temp.index--;
                temp = temp.right;
            }
        }
        else if (target.left) {
            this.tail = target.left;
        }
        this._count--;
        target = null;
    }
    updateAtIndex(index, newData) {
        let target = this.findByIndex(index);
        if (!target)
            return;
        target.data = newData;
    }
    dispose() {
        let temp = new node(null);
        while (this.tail != null) {
            temp = this.tail.left;
            this.tail.left = undefined;
            this.tail.right = undefined;
            this.tail = temp;
        }
        this.head = undefined;
    }
}
class QueryView {
    store;
    source;
    constructor(store, source) {
        this.store = store;
        this.source = source;
    }
    container() {
        throw new Error('Method not implemented.');
    }
    valueContainer() {
        throw new Error('Method not implemented.');
    }
    single(predicate) {
        return this.store.single(predicate, this.Result);
    }
    #cache;
    get Result() {
        this.#cache = Array.from(this._Iterator());
        if (this.sortor) {
            util_mod.InsertOrder(this.#cache, this.sortor, this.ad);
        }
        this.predicate = undefined;
        this.sortor = undefined;
        return this.#cache;
    }
    *_Iterator() {
        if (this.predicate) {
            for (let i of this.source.ergodic()) {
                if (this.predicate(i.data)) {
                    yield i.data;
                }
            }
        }
        else {
            for (let i of this.source.ergodic()) {
                yield i.data;
            }
        }
    }
    predicate;
    ad;
    sortor;
    Select(transform) {
        let temp = new SelectView(this.store, this);
        temp.transform = transform;
        temp.source = this.Result;
        return temp;
    }
    GroupBy(transform) {
        let temp = new GroupView(this);
        temp.transform = transform;
        temp.source = this.Result;
        return temp;
    }
    OrderBy(sortor, se) {
        this.sortor = sortor;
        this.ad = se == 'ascending' ? true : false;
        return this;
    }
}
class SelectView {
    store;
    owner;
    source;
    transform;
    constructor(store, owner) {
        this.store = store;
        this.owner = owner;
    }
    get Result() {
        return this.source?.map(this.transform);
    }
    contains(i) {
        return this.source?.map(this.transform).includes(i) ?? false;
    }
}
class GroupView {
    owner;
    source;
    constructor(owner) {
        this.owner = owner;
    }
    transform;
    get Result() {
        let temp = new Array();
        if (!this.source)
            return temp;
        if (!this.transform)
            return temp;
        for (let i of this.source) {
            let key = this.transform(i);
            let index = temp.findIndex(x => x.key == key);
            if (index == -1) {
                temp.push({ key, value: [i] });
            }
            else {
                temp[index].value.push(i);
            }
        }
        return temp;
    }
}
export class Store {
    source;
    queryView;
    constructor() {
        this.source = new Enumerator();
        this.queryView = new QueryView(this, this.source);
    }
    get count() {
        return this.source._count;
    }
    import(it) {
        if (Array.isArray(it)) {
            let iu = it;
            for (let i of iu) {
                this.source.insert(i);
            }
        }
        else {
            this.source.insert(it);
        }
    }
    dispose() {
        this.source.dispose();
    }
    query(predicate) {
        if (predicate) {
            this.queryView.predicate = predicate;
        }
        return this.queryView;
    }
    container(i, source) {
        var result = false;
        result = source.some(k => k == i);
        return result;
    }
    valueContainer(pridecate, source) {
        var result = false;
        return result;
    }
    single(pridecate, s) {
        let r = new Object();
        for (let i of s) {
            if (pridecate(i)) {
                r = i;
                break;
            }
        }
        return r;
    }
}
export var Set;
(function (Set) {
    class AvlNode {
        data;
        left;
        right;
        height;
        constructor(data) {
            this.data = data;
            this.height = 1;
        }
        insert(node) {
            if (node.data < this.data) {
                if (this.left) {
                    this.left.insert(node);
                }
                else {
                    this.left = node;
                }
            }
            else {
                if (this.right) {
                    this.right.insert(node);
                }
                else {
                    this.right = node;
                }
            }
            this.height = Math.max(this.left?.height ?? 0, this.right?.height ?? 0) + 1;
            let balance = this.balance;
            if (balance > 1) {
                if (node.data < this.left.data) {
                    this.rightRotate();
                }
                else {
                    this.left.leftRotate();
                    this.rightRotate();
                }
            }
            else if (balance < -1) {
                if (node.data > this.right.data) {
                    this.leftRotate();
                }
                else {
                    this.right.rightRotate();
                    this.leftRotate();
                }
            }
        }
        remove(data) {
            if (data < this.data) {
                if (this.left) {
                    this.left = this.left.remove(data);
                }
            }
            else if (data > this.data) {
                if (this.right) {
                    this.right = this.right.remove(data);
                }
            }
            else {
                if (!this.left && !this.right) {
                    return null;
                }
                else if (this.left && !this.right) {
                    return this.left;
                }
                else if (!this.left && this.right) {
                    return this.right;
                }
                else {
                    let temp = this.right;
                    while (temp.left) {
                        temp = temp.left;
                    }
                    this.data = temp.data;
                    this.right = this.right.remove(temp.data);
                }
            }
            this.height = Math.max(this.left?.height ?? 0, this.right?.height ?? 0) + 1;
            let balance = this.balance;
            if (balance > 1) {
                if (this.left.balance >= 0) {
                    this.rightRotate();
                }
                else {
                    this.left.leftRotate();
                    this.rightRotate();
                }
            }
            else if (balance < -1) {
                if (this.right.balance <= 0) {
                    this.leftRotate();
                }
                else {
                    this.right.rightRotate();
                    this.leftRotate();
                }
            }
            return this;
        }
        find(data) {
            if (data < this.data) {
                if (this.left) {
                    return this.left.find(data);
                }
            }
            else if (data > this.data) {
                if (this.right) {
                    return this.right.find(data);
                }
            }
            else {
                return this;
            }
            return null;
        }
        *ergodic(isReverse) {
            let temp;
            if (isReverse) {
                temp = this.right;
                while (temp) {
                    yield temp;
                    temp = temp.left;
                }
            }
            else {
                temp = this.left;
                while (temp) {
                    yield temp;
                    temp = temp.right;
                }
            }
        }
        get balance() {
            return (this.left?.height ?? 0) - (this.right?.height ?? 0);
        }
        rightRotate() {
            let temp = new AvlNode(this.data);
            temp.left = this.left?.right;
            temp.right = this.right;
            this.data = this.left.data;
            this.left = this.left?.left;
            this.right = temp;
            this.height = Math.max(this.left?.height ?? 0, this.right?.height ?? 0) + 1;
        }
        leftRotate() {
            let temp = new AvlNode(this.data);
            temp.left = this.left;
            temp.right = this.right?.left;
            this.data = this.right.data;
            this.left = temp;
            this.right = this.right?.right;
            this.height = Math.max(this.left?.height ?? 0, this.right?.height ?? 0) + 1;
        }
    }
    Set.AvlNode = AvlNode;
    class AvlTree {
        root;
        constructor() {
            this.root = null;
        }
        insert(data) {
            let temp = new AvlNode(data);
            if (!this.root) {
                this.root = temp;
            }
            else {
                this.root.insert(temp);
            }
        }
        remove(data) {
            if (!this.root)
                return;
            this.root = this.root.remove(data);
        }
        find(data) {
            if (!this.root)
                return null;
            return this.root.find(data);
        }
        ergodic(isReverse) {
            if (!this.root)
                return [];
            return this.root.ergodic(isReverse);
        }
    }
    Set.AvlTree = AvlTree;
    class GraphNode {
        data;
        _edges;
        constructor(data) {
            this.data = data;
            this._edges = new Map();
        }
        get edges() {
            return this._edges;
        }
        addEdge(node, weight) {
            this._edges.set(node, weight);
        }
        removeEdge(node) {
            this._edges.delete(node);
        }
    }
    Set.GraphNode = GraphNode;
    class Edge {
        from;
        to;
        weight;
        constructor(from, to, weight) {
            this.from = from;
            this.to = to;
            this.weight = weight;
        }
    }
    Set.Edge = Edge;
    class Graph {
        _nodes;
        _edges;
        constructor() {
            this._nodes = new Map();
            this._edges = [];
        }
        addNode(data) {
            this._nodes.set(data, new GraphNode(data));
        }
        removeNode(data) {
            this._nodes.delete(data);
            for (let i of this._nodes.values()) {
                i.edges.delete(this._nodes.get(data));
            }
        }
        addEdge(from, to, weight) {
            this._nodes.get(from)?.addEdge(this._nodes.get(to), weight);
        }
        removeEdge(from, to) {
            this._nodes.get(from)?.removeEdge(this._nodes.get(to));
        }
    }
    Set.Graph = Graph;
})(Set || (Set = {}));
