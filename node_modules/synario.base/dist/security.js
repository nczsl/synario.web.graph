export function uuid() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
        var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
        return v.toString(16);
    }).toUpperCase();
}
export function randomNum() {
    return window.crypto.getRandomValues(new Uint32Array(1))[0];
}
export function encode(str) {
    return new TextEncoder().encode(str);
}
export function decode(buffer, format = 'ascii') {
    return new TextDecoder(format).decode(buffer);
}
export class EcdhSecurity {
    generateIv() {
        return crypto.getRandomValues(new Uint8Array(16));
    }
    key;
    sessionkey;
    async generateKey() {
        let keyUsages = ['deriveKey', 'deriveBits'];
        this.key = await window.crypto.subtle.generateKey({ name: 'ECDH', namedCurve: 'P-256' }, false, keyUsages);
    }
    async exportKey() {
        await this.generateKey();
        let keyobj = await window.crypto.subtle.exportKey('raw', this.key.publicKey);
        return new Uint8Array(keyobj);
    }
    async importKey(keyobj) {
        let remotekey = await window.crypto.subtle.importKey('raw', keyobj, { name: 'ECDH', namedCurve: 'P-256' }, false, []);
        await this.setRemotePublicKey(remotekey);
    }
    async encrypt(plaintext) {
        let iv = this.generateIv();
        const buffer = await crypto.subtle.encrypt({
            name: 'AES-CBC',
            iv,
            length: 128
        }, this.sessionkey, encode(plaintext));
        return { buffer, iv };
    }
    async decrypt(data) {
        const buffer = await crypto.subtle.decrypt({
            name: 'AES-CBC',
            iv: data.iv,
            length: 128
        }, this.sessionkey, data.buffer);
        return decode(buffer);
    }
    async setRemotePublicKey(remotekey) {
        this.sessionkey = await crypto.subtle.deriveKey({ name: 'ECDH', public: remotekey }, this.key.privateKey, { name: 'AES-CBC', length: 128 }, false, ['encrypt', 'decrypt']);
    }
}
